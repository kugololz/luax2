Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> block
Rule 3     block -> blocklist
Rule 4     blocklist -> command blockterminator blocklist
Rule 5     blocklist -> empty
Rule 6     blockterminator -> empty
Rule 7     blockterminator -> SEMICOLON
Rule 8     command -> ID ASSIGN exp
Rule 9     command -> functioncall
Rule 10    command -> vardeclaration
Rule 11    command -> localdeclaration
Rule 12    command -> functiondeclaration
Rule 13    command -> varassignmultiple
Rule 14    command -> WHILE exp DO block END
Rule 15    command -> IF exp THEN block elsestnt END
Rule 16    command -> RETURN explist
Rule 17    expassign -> ASSIGN exp
Rule 18    expassign -> empty
Rule 19    localdeclaration -> LOCAL ID expassign
Rule 20    varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall
Rule 21    vardeclaration -> VAR ID expassign
Rule 22    functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
Rule 23    functioncall -> ID LPAREN explist RPAREN
Rule 24    paramlist -> empty
Rule 25    paramlist -> paramseq
Rule 26    paramseq -> ID
Rule 27    paramseq -> ID COMMA paramseq
Rule 28    explist -> empty
Rule 29    explist -> exp
Rule 30    explist -> exp COMMA explist
Rule 31    exp -> NUMBER
Rule 32    exp -> ID
Rule 33    exp -> STRING
Rule 34    exp -> functioncall
Rule 35    exp -> exp PLUS exp
Rule 36    exp -> exp MINUS exp
Rule 37    exp -> exp TIMES exp
Rule 38    exp -> exp DIVIDE exp
Rule 39    exp -> exp MOD exp
Rule 40    exp -> exp AND exp
Rule 41    exp -> exp OR exp
Rule 42    exp -> exp LESS exp
Rule 43    exp -> exp LESSEQUAL exp
Rule 44    exp -> exp GREATER exp
Rule 45    exp -> exp GREATEREQUAL exp
Rule 46    exp -> exp EQUAL exp
Rule 47    exp -> exp NOTEQUAL exp
Rule 48    exp -> exp CONCAT exp
Rule 49    exp -> NOT exp
Rule 50    exp -> MINUS exp
Rule 51    elsestnt -> empty
Rule 52    elsestnt -> ELSE block

Terminals, with rules where they appear

AND                  : 40
ASSIGN               : 8 17 20
COMMA                : 20 27 30
CONCAT               : 48
DIVIDE               : 38
DO                   : 14
ELSE                 : 52
END                  : 14 15 22
EQUAL                : 46
FUNCTION             : 22
GREATER              : 44
GREATEREQUAL         : 45
ID                   : 8 19 20 20 21 22 23 26 27 32
IF                   : 15
LESS                 : 42
LESSEQUAL            : 43
LOCAL                : 19 20 22
LPAREN               : 22 23
MINUS                : 36 50
MOD                  : 39
NOT                  : 49
NOTEQUAL             : 47
NUMBER               : 31
OR                   : 41
PLUS                 : 35
RETURN               : 16
RPAREN               : 22 23
SEMICOLON            : 7
STRING               : 33
THEN                 : 15
TIMES                : 37
VAR                  : 21
WHILE                : 14
error                : 

Nonterminals, with rules where they appear

block                : 2 14 15 22 52
blocklist            : 3 4
blockterminator      : 4
command              : 4
elsestnt             : 15
empty                : 5 6 18 24 28 51
exp                  : 8 14 15 17 29 30 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 50
expassign            : 19 21
explist              : 16 23 30
functioncall         : 9 20 34
functiondeclaration  : 12
localdeclaration     : 11
paramlist            : 22
paramseq             : 25 27
program              : 0
varassignmultiple    : 13
vardeclaration       : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . block
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    $end            reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    program                        shift and go to state 1
    block                          shift and go to state 2
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (2) program -> block .

    $end            reduce using rule 2 (program -> block .)


state 3

    (3) block -> blocklist .

    $end            reduce using rule 3 (block -> blocklist .)
    END             reduce using rule 3 (block -> blocklist .)
    ELSE            reduce using rule 3 (block -> blocklist .)


state 4

    (4) blocklist -> command . blockterminator blocklist
    (6) blockterminator -> . empty
    (7) blockterminator -> . SEMICOLON
    (1) empty -> .

    SEMICOLON       shift and go to state 19
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    blockterminator                shift and go to state 17
    empty                          shift and go to state 18

state 5

    (5) blocklist -> empty .

    $end            reduce using rule 5 (blocklist -> empty .)
    END             reduce using rule 5 (blocklist -> empty .)
    ELSE            reduce using rule 5 (blocklist -> empty .)


state 6

    (8) command -> ID . ASSIGN exp
    (23) functioncall -> ID . LPAREN explist RPAREN

    ASSIGN          shift and go to state 20
    LPAREN          shift and go to state 21


state 7

    (9) command -> functioncall .

    SEMICOLON       reduce using rule 9 (command -> functioncall .)
    ID              reduce using rule 9 (command -> functioncall .)
    WHILE           reduce using rule 9 (command -> functioncall .)
    IF              reduce using rule 9 (command -> functioncall .)
    RETURN          reduce using rule 9 (command -> functioncall .)
    VAR             reduce using rule 9 (command -> functioncall .)
    LOCAL           reduce using rule 9 (command -> functioncall .)
    $end            reduce using rule 9 (command -> functioncall .)
    END             reduce using rule 9 (command -> functioncall .)
    ELSE            reduce using rule 9 (command -> functioncall .)


state 8

    (10) command -> vardeclaration .

    SEMICOLON       reduce using rule 10 (command -> vardeclaration .)
    ID              reduce using rule 10 (command -> vardeclaration .)
    WHILE           reduce using rule 10 (command -> vardeclaration .)
    IF              reduce using rule 10 (command -> vardeclaration .)
    RETURN          reduce using rule 10 (command -> vardeclaration .)
    VAR             reduce using rule 10 (command -> vardeclaration .)
    LOCAL           reduce using rule 10 (command -> vardeclaration .)
    $end            reduce using rule 10 (command -> vardeclaration .)
    END             reduce using rule 10 (command -> vardeclaration .)
    ELSE            reduce using rule 10 (command -> vardeclaration .)


state 9

    (11) command -> localdeclaration .

    SEMICOLON       reduce using rule 11 (command -> localdeclaration .)
    ID              reduce using rule 11 (command -> localdeclaration .)
    WHILE           reduce using rule 11 (command -> localdeclaration .)
    IF              reduce using rule 11 (command -> localdeclaration .)
    RETURN          reduce using rule 11 (command -> localdeclaration .)
    VAR             reduce using rule 11 (command -> localdeclaration .)
    LOCAL           reduce using rule 11 (command -> localdeclaration .)
    $end            reduce using rule 11 (command -> localdeclaration .)
    END             reduce using rule 11 (command -> localdeclaration .)
    ELSE            reduce using rule 11 (command -> localdeclaration .)


state 10

    (12) command -> functiondeclaration .

    SEMICOLON       reduce using rule 12 (command -> functiondeclaration .)
    ID              reduce using rule 12 (command -> functiondeclaration .)
    WHILE           reduce using rule 12 (command -> functiondeclaration .)
    IF              reduce using rule 12 (command -> functiondeclaration .)
    RETURN          reduce using rule 12 (command -> functiondeclaration .)
    VAR             reduce using rule 12 (command -> functiondeclaration .)
    LOCAL           reduce using rule 12 (command -> functiondeclaration .)
    $end            reduce using rule 12 (command -> functiondeclaration .)
    END             reduce using rule 12 (command -> functiondeclaration .)
    ELSE            reduce using rule 12 (command -> functiondeclaration .)


state 11

    (13) command -> varassignmultiple .

    SEMICOLON       reduce using rule 13 (command -> varassignmultiple .)
    ID              reduce using rule 13 (command -> varassignmultiple .)
    WHILE           reduce using rule 13 (command -> varassignmultiple .)
    IF              reduce using rule 13 (command -> varassignmultiple .)
    RETURN          reduce using rule 13 (command -> varassignmultiple .)
    VAR             reduce using rule 13 (command -> varassignmultiple .)
    LOCAL           reduce using rule 13 (command -> varassignmultiple .)
    $end            reduce using rule 13 (command -> varassignmultiple .)
    END             reduce using rule 13 (command -> varassignmultiple .)
    ELSE            reduce using rule 13 (command -> varassignmultiple .)


state 12

    (14) command -> WHILE . exp DO block END
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 22
    functioncall                   shift and go to state 26

state 13

    (15) command -> IF . exp THEN block elsestnt END
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 29
    functioncall                   shift and go to state 26

state 14

    (16) command -> RETURN . explist
    (28) explist -> . empty
    (29) explist -> . exp
    (30) explist -> . exp COMMA explist
    (1) empty -> .
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

  ! shift/reduce conflict for ID resolved as shift
    SEMICOLON       reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

  ! ID              [ reduce using rule 1 (empty -> .) ]

    explist                        shift and go to state 30
    empty                          shift and go to state 31
    exp                            shift and go to state 32
    functioncall                   shift and go to state 26

state 15

    (21) vardeclaration -> VAR . ID expassign

    ID              shift and go to state 33


state 16

    (19) localdeclaration -> LOCAL . ID expassign
    (22) functiondeclaration -> LOCAL . FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> LOCAL . ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 34
    FUNCTION        shift and go to state 35


state 17

    (4) blocklist -> command blockterminator . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    command                        shift and go to state 4
    blocklist                      shift and go to state 36
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 18

    (6) blockterminator -> empty .

    ID              reduce using rule 6 (blockterminator -> empty .)
    WHILE           reduce using rule 6 (blockterminator -> empty .)
    IF              reduce using rule 6 (blockterminator -> empty .)
    RETURN          reduce using rule 6 (blockterminator -> empty .)
    VAR             reduce using rule 6 (blockterminator -> empty .)
    LOCAL           reduce using rule 6 (blockterminator -> empty .)
    $end            reduce using rule 6 (blockterminator -> empty .)
    END             reduce using rule 6 (blockterminator -> empty .)
    ELSE            reduce using rule 6 (blockterminator -> empty .)


state 19

    (7) blockterminator -> SEMICOLON .

    ID              reduce using rule 7 (blockterminator -> SEMICOLON .)
    WHILE           reduce using rule 7 (blockterminator -> SEMICOLON .)
    IF              reduce using rule 7 (blockterminator -> SEMICOLON .)
    RETURN          reduce using rule 7 (blockterminator -> SEMICOLON .)
    VAR             reduce using rule 7 (blockterminator -> SEMICOLON .)
    LOCAL           reduce using rule 7 (blockterminator -> SEMICOLON .)
    $end            reduce using rule 7 (blockterminator -> SEMICOLON .)
    END             reduce using rule 7 (blockterminator -> SEMICOLON .)
    ELSE            reduce using rule 7 (blockterminator -> SEMICOLON .)


state 20

    (8) command -> ID ASSIGN . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 37
    functioncall                   shift and go to state 26

state 21

    (23) functioncall -> ID LPAREN . explist RPAREN
    (28) explist -> . empty
    (29) explist -> . exp
    (30) explist -> . exp COMMA explist
    (1) empty -> .
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    RPAREN          reduce using rule 1 (empty -> .)
    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    explist                        shift and go to state 38
    empty                          shift and go to state 31
    exp                            shift and go to state 32
    functioncall                   shift and go to state 26

state 22

    (14) command -> WHILE exp . DO block END
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53


state 23

    (31) exp -> NUMBER .

    DO              reduce using rule 31 (exp -> NUMBER .)
    PLUS            reduce using rule 31 (exp -> NUMBER .)
    MINUS           reduce using rule 31 (exp -> NUMBER .)
    TIMES           reduce using rule 31 (exp -> NUMBER .)
    DIVIDE          reduce using rule 31 (exp -> NUMBER .)
    MOD             reduce using rule 31 (exp -> NUMBER .)
    AND             reduce using rule 31 (exp -> NUMBER .)
    OR              reduce using rule 31 (exp -> NUMBER .)
    LESS            reduce using rule 31 (exp -> NUMBER .)
    LESSEQUAL       reduce using rule 31 (exp -> NUMBER .)
    GREATER         reduce using rule 31 (exp -> NUMBER .)
    GREATEREQUAL    reduce using rule 31 (exp -> NUMBER .)
    EQUAL           reduce using rule 31 (exp -> NUMBER .)
    NOTEQUAL        reduce using rule 31 (exp -> NUMBER .)
    CONCAT          reduce using rule 31 (exp -> NUMBER .)
    THEN            reduce using rule 31 (exp -> NUMBER .)
    COMMA           reduce using rule 31 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 31 (exp -> NUMBER .)
    ID              reduce using rule 31 (exp -> NUMBER .)
    WHILE           reduce using rule 31 (exp -> NUMBER .)
    IF              reduce using rule 31 (exp -> NUMBER .)
    RETURN          reduce using rule 31 (exp -> NUMBER .)
    VAR             reduce using rule 31 (exp -> NUMBER .)
    LOCAL           reduce using rule 31 (exp -> NUMBER .)
    $end            reduce using rule 31 (exp -> NUMBER .)
    END             reduce using rule 31 (exp -> NUMBER .)
    ELSE            reduce using rule 31 (exp -> NUMBER .)
    RPAREN          reduce using rule 31 (exp -> NUMBER .)


state 24

    (32) exp -> ID .
    (23) functioncall -> ID . LPAREN explist RPAREN

    DO              reduce using rule 32 (exp -> ID .)
    PLUS            reduce using rule 32 (exp -> ID .)
    MINUS           reduce using rule 32 (exp -> ID .)
    TIMES           reduce using rule 32 (exp -> ID .)
    DIVIDE          reduce using rule 32 (exp -> ID .)
    MOD             reduce using rule 32 (exp -> ID .)
    AND             reduce using rule 32 (exp -> ID .)
    OR              reduce using rule 32 (exp -> ID .)
    LESS            reduce using rule 32 (exp -> ID .)
    LESSEQUAL       reduce using rule 32 (exp -> ID .)
    GREATER         reduce using rule 32 (exp -> ID .)
    GREATEREQUAL    reduce using rule 32 (exp -> ID .)
    EQUAL           reduce using rule 32 (exp -> ID .)
    NOTEQUAL        reduce using rule 32 (exp -> ID .)
    CONCAT          reduce using rule 32 (exp -> ID .)
    THEN            reduce using rule 32 (exp -> ID .)
    COMMA           reduce using rule 32 (exp -> ID .)
    SEMICOLON       reduce using rule 32 (exp -> ID .)
    ID              reduce using rule 32 (exp -> ID .)
    WHILE           reduce using rule 32 (exp -> ID .)
    IF              reduce using rule 32 (exp -> ID .)
    RETURN          reduce using rule 32 (exp -> ID .)
    VAR             reduce using rule 32 (exp -> ID .)
    LOCAL           reduce using rule 32 (exp -> ID .)
    $end            reduce using rule 32 (exp -> ID .)
    END             reduce using rule 32 (exp -> ID .)
    ELSE            reduce using rule 32 (exp -> ID .)
    RPAREN          reduce using rule 32 (exp -> ID .)
    LPAREN          shift and go to state 21


state 25

    (33) exp -> STRING .

    DO              reduce using rule 33 (exp -> STRING .)
    PLUS            reduce using rule 33 (exp -> STRING .)
    MINUS           reduce using rule 33 (exp -> STRING .)
    TIMES           reduce using rule 33 (exp -> STRING .)
    DIVIDE          reduce using rule 33 (exp -> STRING .)
    MOD             reduce using rule 33 (exp -> STRING .)
    AND             reduce using rule 33 (exp -> STRING .)
    OR              reduce using rule 33 (exp -> STRING .)
    LESS            reduce using rule 33 (exp -> STRING .)
    LESSEQUAL       reduce using rule 33 (exp -> STRING .)
    GREATER         reduce using rule 33 (exp -> STRING .)
    GREATEREQUAL    reduce using rule 33 (exp -> STRING .)
    EQUAL           reduce using rule 33 (exp -> STRING .)
    NOTEQUAL        reduce using rule 33 (exp -> STRING .)
    CONCAT          reduce using rule 33 (exp -> STRING .)
    THEN            reduce using rule 33 (exp -> STRING .)
    COMMA           reduce using rule 33 (exp -> STRING .)
    SEMICOLON       reduce using rule 33 (exp -> STRING .)
    ID              reduce using rule 33 (exp -> STRING .)
    WHILE           reduce using rule 33 (exp -> STRING .)
    IF              reduce using rule 33 (exp -> STRING .)
    RETURN          reduce using rule 33 (exp -> STRING .)
    VAR             reduce using rule 33 (exp -> STRING .)
    LOCAL           reduce using rule 33 (exp -> STRING .)
    $end            reduce using rule 33 (exp -> STRING .)
    END             reduce using rule 33 (exp -> STRING .)
    ELSE            reduce using rule 33 (exp -> STRING .)
    RPAREN          reduce using rule 33 (exp -> STRING .)


state 26

    (34) exp -> functioncall .

    DO              reduce using rule 34 (exp -> functioncall .)
    PLUS            reduce using rule 34 (exp -> functioncall .)
    MINUS           reduce using rule 34 (exp -> functioncall .)
    TIMES           reduce using rule 34 (exp -> functioncall .)
    DIVIDE          reduce using rule 34 (exp -> functioncall .)
    MOD             reduce using rule 34 (exp -> functioncall .)
    AND             reduce using rule 34 (exp -> functioncall .)
    OR              reduce using rule 34 (exp -> functioncall .)
    LESS            reduce using rule 34 (exp -> functioncall .)
    LESSEQUAL       reduce using rule 34 (exp -> functioncall .)
    GREATER         reduce using rule 34 (exp -> functioncall .)
    GREATEREQUAL    reduce using rule 34 (exp -> functioncall .)
    EQUAL           reduce using rule 34 (exp -> functioncall .)
    NOTEQUAL        reduce using rule 34 (exp -> functioncall .)
    CONCAT          reduce using rule 34 (exp -> functioncall .)
    THEN            reduce using rule 34 (exp -> functioncall .)
    COMMA           reduce using rule 34 (exp -> functioncall .)
    SEMICOLON       reduce using rule 34 (exp -> functioncall .)
    ID              reduce using rule 34 (exp -> functioncall .)
    WHILE           reduce using rule 34 (exp -> functioncall .)
    IF              reduce using rule 34 (exp -> functioncall .)
    RETURN          reduce using rule 34 (exp -> functioncall .)
    VAR             reduce using rule 34 (exp -> functioncall .)
    LOCAL           reduce using rule 34 (exp -> functioncall .)
    $end            reduce using rule 34 (exp -> functioncall .)
    END             reduce using rule 34 (exp -> functioncall .)
    ELSE            reduce using rule 34 (exp -> functioncall .)
    RPAREN          reduce using rule 34 (exp -> functioncall .)


state 27

    (50) exp -> MINUS . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 54
    functioncall                   shift and go to state 26

state 28

    (49) exp -> NOT . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 55
    functioncall                   shift and go to state 26

state 29

    (15) command -> IF exp . THEN block elsestnt END
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    THEN            shift and go to state 56
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53


state 30

    (16) command -> RETURN explist .

    SEMICOLON       reduce using rule 16 (command -> RETURN explist .)
    ID              reduce using rule 16 (command -> RETURN explist .)
    WHILE           reduce using rule 16 (command -> RETURN explist .)
    IF              reduce using rule 16 (command -> RETURN explist .)
    RETURN          reduce using rule 16 (command -> RETURN explist .)
    VAR             reduce using rule 16 (command -> RETURN explist .)
    LOCAL           reduce using rule 16 (command -> RETURN explist .)
    $end            reduce using rule 16 (command -> RETURN explist .)
    END             reduce using rule 16 (command -> RETURN explist .)
    ELSE            reduce using rule 16 (command -> RETURN explist .)


state 31

    (28) explist -> empty .

    SEMICOLON       reduce using rule 28 (explist -> empty .)
    ID              reduce using rule 28 (explist -> empty .)
    WHILE           reduce using rule 28 (explist -> empty .)
    IF              reduce using rule 28 (explist -> empty .)
    RETURN          reduce using rule 28 (explist -> empty .)
    VAR             reduce using rule 28 (explist -> empty .)
    LOCAL           reduce using rule 28 (explist -> empty .)
    $end            reduce using rule 28 (explist -> empty .)
    END             reduce using rule 28 (explist -> empty .)
    ELSE            reduce using rule 28 (explist -> empty .)
    RPAREN          reduce using rule 28 (explist -> empty .)


state 32

    (29) explist -> exp .
    (30) explist -> exp . COMMA explist
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 29 (explist -> exp .)
    ID              reduce using rule 29 (explist -> exp .)
    WHILE           reduce using rule 29 (explist -> exp .)
    IF              reduce using rule 29 (explist -> exp .)
    RETURN          reduce using rule 29 (explist -> exp .)
    VAR             reduce using rule 29 (explist -> exp .)
    LOCAL           reduce using rule 29 (explist -> exp .)
    $end            reduce using rule 29 (explist -> exp .)
    END             reduce using rule 29 (explist -> exp .)
    ELSE            reduce using rule 29 (explist -> exp .)
    RPAREN          reduce using rule 29 (explist -> exp .)
    COMMA           shift and go to state 57
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53


state 33

    (21) vardeclaration -> VAR ID . expassign
    (17) expassign -> . ASSIGN exp
    (18) expassign -> . empty
    (1) empty -> .

    ASSIGN          shift and go to state 59
    SEMICOLON       reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    expassign                      shift and go to state 58
    empty                          shift and go to state 60

state 34

    (19) localdeclaration -> LOCAL ID . expassign
    (20) varassignmultiple -> LOCAL ID . COMMA ID ASSIGN functioncall
    (17) expassign -> . ASSIGN exp
    (18) expassign -> . empty
    (1) empty -> .

    COMMA           shift and go to state 62
    ASSIGN          shift and go to state 59
    SEMICOLON       reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    expassign                      shift and go to state 61
    empty                          shift and go to state 60

state 35

    (22) functiondeclaration -> LOCAL FUNCTION . ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 63


state 36

    (4) blocklist -> command blockterminator blocklist .

    $end            reduce using rule 4 (blocklist -> command blockterminator blocklist .)
    END             reduce using rule 4 (blocklist -> command blockterminator blocklist .)
    ELSE            reduce using rule 4 (blocklist -> command blockterminator blocklist .)


state 37

    (8) command -> ID ASSIGN exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 8 (command -> ID ASSIGN exp .)
    ID              reduce using rule 8 (command -> ID ASSIGN exp .)
    WHILE           reduce using rule 8 (command -> ID ASSIGN exp .)
    IF              reduce using rule 8 (command -> ID ASSIGN exp .)
    RETURN          reduce using rule 8 (command -> ID ASSIGN exp .)
    VAR             reduce using rule 8 (command -> ID ASSIGN exp .)
    LOCAL           reduce using rule 8 (command -> ID ASSIGN exp .)
    $end            reduce using rule 8 (command -> ID ASSIGN exp .)
    END             reduce using rule 8 (command -> ID ASSIGN exp .)
    ELSE            reduce using rule 8 (command -> ID ASSIGN exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53


state 38

    (23) functioncall -> ID LPAREN explist . RPAREN

    RPAREN          shift and go to state 64


state 39

    (14) command -> WHILE exp DO . block END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    block                          shift and go to state 65
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 40

    (35) exp -> exp PLUS . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 66
    functioncall                   shift and go to state 26

state 41

    (36) exp -> exp MINUS . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 67
    functioncall                   shift and go to state 26

state 42

    (37) exp -> exp TIMES . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 68
    functioncall                   shift and go to state 26

state 43

    (38) exp -> exp DIVIDE . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 69
    functioncall                   shift and go to state 26

state 44

    (39) exp -> exp MOD . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 70
    functioncall                   shift and go to state 26

state 45

    (40) exp -> exp AND . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 71
    functioncall                   shift and go to state 26

state 46

    (41) exp -> exp OR . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 72
    functioncall                   shift and go to state 26

state 47

    (42) exp -> exp LESS . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 73
    functioncall                   shift and go to state 26

state 48

    (43) exp -> exp LESSEQUAL . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 74
    functioncall                   shift and go to state 26

state 49

    (44) exp -> exp GREATER . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 75
    functioncall                   shift and go to state 26

state 50

    (45) exp -> exp GREATEREQUAL . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 76
    functioncall                   shift and go to state 26

state 51

    (46) exp -> exp EQUAL . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 77
    functioncall                   shift and go to state 26

state 52

    (47) exp -> exp NOTEQUAL . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 78
    functioncall                   shift and go to state 26

state 53

    (48) exp -> exp CONCAT . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 79
    functioncall                   shift and go to state 26

state 54

    (50) exp -> MINUS exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 50 (exp -> MINUS exp .)
    PLUS            reduce using rule 50 (exp -> MINUS exp .)
    MINUS           reduce using rule 50 (exp -> MINUS exp .)
    TIMES           reduce using rule 50 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 50 (exp -> MINUS exp .)
    MOD             reduce using rule 50 (exp -> MINUS exp .)
    AND             reduce using rule 50 (exp -> MINUS exp .)
    OR              reduce using rule 50 (exp -> MINUS exp .)
    LESS            reduce using rule 50 (exp -> MINUS exp .)
    LESSEQUAL       reduce using rule 50 (exp -> MINUS exp .)
    GREATER         reduce using rule 50 (exp -> MINUS exp .)
    GREATEREQUAL    reduce using rule 50 (exp -> MINUS exp .)
    EQUAL           reduce using rule 50 (exp -> MINUS exp .)
    NOTEQUAL        reduce using rule 50 (exp -> MINUS exp .)
    CONCAT          reduce using rule 50 (exp -> MINUS exp .)
    THEN            reduce using rule 50 (exp -> MINUS exp .)
    COMMA           reduce using rule 50 (exp -> MINUS exp .)
    SEMICOLON       reduce using rule 50 (exp -> MINUS exp .)
    ID              reduce using rule 50 (exp -> MINUS exp .)
    WHILE           reduce using rule 50 (exp -> MINUS exp .)
    IF              reduce using rule 50 (exp -> MINUS exp .)
    RETURN          reduce using rule 50 (exp -> MINUS exp .)
    VAR             reduce using rule 50 (exp -> MINUS exp .)
    LOCAL           reduce using rule 50 (exp -> MINUS exp .)
    $end            reduce using rule 50 (exp -> MINUS exp .)
    END             reduce using rule 50 (exp -> MINUS exp .)
    ELSE            reduce using rule 50 (exp -> MINUS exp .)
    RPAREN          reduce using rule 50 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! MOD             [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]
  ! CONCAT          [ shift and go to state 53 ]


state 55

    (49) exp -> NOT exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 49 (exp -> NOT exp .)
    PLUS            reduce using rule 49 (exp -> NOT exp .)
    MINUS           reduce using rule 49 (exp -> NOT exp .)
    TIMES           reduce using rule 49 (exp -> NOT exp .)
    DIVIDE          reduce using rule 49 (exp -> NOT exp .)
    MOD             reduce using rule 49 (exp -> NOT exp .)
    AND             reduce using rule 49 (exp -> NOT exp .)
    OR              reduce using rule 49 (exp -> NOT exp .)
    LESS            reduce using rule 49 (exp -> NOT exp .)
    LESSEQUAL       reduce using rule 49 (exp -> NOT exp .)
    GREATER         reduce using rule 49 (exp -> NOT exp .)
    GREATEREQUAL    reduce using rule 49 (exp -> NOT exp .)
    EQUAL           reduce using rule 49 (exp -> NOT exp .)
    NOTEQUAL        reduce using rule 49 (exp -> NOT exp .)
    CONCAT          reduce using rule 49 (exp -> NOT exp .)
    THEN            reduce using rule 49 (exp -> NOT exp .)
    COMMA           reduce using rule 49 (exp -> NOT exp .)
    SEMICOLON       reduce using rule 49 (exp -> NOT exp .)
    ID              reduce using rule 49 (exp -> NOT exp .)
    WHILE           reduce using rule 49 (exp -> NOT exp .)
    IF              reduce using rule 49 (exp -> NOT exp .)
    RETURN          reduce using rule 49 (exp -> NOT exp .)
    VAR             reduce using rule 49 (exp -> NOT exp .)
    LOCAL           reduce using rule 49 (exp -> NOT exp .)
    $end            reduce using rule 49 (exp -> NOT exp .)
    END             reduce using rule 49 (exp -> NOT exp .)
    ELSE            reduce using rule 49 (exp -> NOT exp .)
    RPAREN          reduce using rule 49 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! MOD             [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]
  ! CONCAT          [ shift and go to state 53 ]


state 56

    (15) command -> IF exp THEN . block elsestnt END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    ELSE            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    block                          shift and go to state 80
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 57

    (30) explist -> exp COMMA . explist
    (28) explist -> . empty
    (29) explist -> . exp
    (30) explist -> . exp COMMA explist
    (1) empty -> .
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

  ! shift/reduce conflict for ID resolved as shift
    SEMICOLON       reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

  ! ID              [ reduce using rule 1 (empty -> .) ]

    exp                            shift and go to state 32
    explist                        shift and go to state 81
    empty                          shift and go to state 31
    functioncall                   shift and go to state 26

state 58

    (21) vardeclaration -> VAR ID expassign .

    SEMICOLON       reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    ID              reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    WHILE           reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    IF              reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    RETURN          reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    VAR             reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    LOCAL           reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    $end            reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    END             reduce using rule 21 (vardeclaration -> VAR ID expassign .)
    ELSE            reduce using rule 21 (vardeclaration -> VAR ID expassign .)


state 59

    (17) expassign -> ASSIGN . exp
    (31) exp -> . NUMBER
    (32) exp -> . ID
    (33) exp -> . STRING
    (34) exp -> . functioncall
    (35) exp -> . exp PLUS exp
    (36) exp -> . exp MINUS exp
    (37) exp -> . exp TIMES exp
    (38) exp -> . exp DIVIDE exp
    (39) exp -> . exp MOD exp
    (40) exp -> . exp AND exp
    (41) exp -> . exp OR exp
    (42) exp -> . exp LESS exp
    (43) exp -> . exp LESSEQUAL exp
    (44) exp -> . exp GREATER exp
    (45) exp -> . exp GREATEREQUAL exp
    (46) exp -> . exp EQUAL exp
    (47) exp -> . exp NOTEQUAL exp
    (48) exp -> . exp CONCAT exp
    (49) exp -> . NOT exp
    (50) exp -> . MINUS exp
    (23) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 23
    ID              shift and go to state 24
    STRING          shift and go to state 25
    NOT             shift and go to state 28
    MINUS           shift and go to state 27

    exp                            shift and go to state 82
    functioncall                   shift and go to state 26

state 60

    (18) expassign -> empty .

    SEMICOLON       reduce using rule 18 (expassign -> empty .)
    ID              reduce using rule 18 (expassign -> empty .)
    WHILE           reduce using rule 18 (expassign -> empty .)
    IF              reduce using rule 18 (expassign -> empty .)
    RETURN          reduce using rule 18 (expassign -> empty .)
    VAR             reduce using rule 18 (expassign -> empty .)
    LOCAL           reduce using rule 18 (expassign -> empty .)
    $end            reduce using rule 18 (expassign -> empty .)
    END             reduce using rule 18 (expassign -> empty .)
    ELSE            reduce using rule 18 (expassign -> empty .)


state 61

    (19) localdeclaration -> LOCAL ID expassign .

    SEMICOLON       reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    ID              reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    WHILE           reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    IF              reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    RETURN          reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    VAR             reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    LOCAL           reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    $end            reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    END             reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)
    ELSE            reduce using rule 19 (localdeclaration -> LOCAL ID expassign .)


state 62

    (20) varassignmultiple -> LOCAL ID COMMA . ID ASSIGN functioncall

    ID              shift and go to state 83


state 63

    (22) functiondeclaration -> LOCAL FUNCTION ID . LPAREN paramlist RPAREN block END

    LPAREN          shift and go to state 84


state 64

    (23) functioncall -> ID LPAREN explist RPAREN .

    SEMICOLON       reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    ID              reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    WHILE           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    IF              reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    RETURN          reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    VAR             reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    LOCAL           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    $end            reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    DO              reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    PLUS            reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    MINUS           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    TIMES           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    DIVIDE          reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    MOD             reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    AND             reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    OR              reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    LESS            reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    LESSEQUAL       reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    GREATER         reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    GREATEREQUAL    reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    EQUAL           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    NOTEQUAL        reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    CONCAT          reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    THEN            reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    COMMA           reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    END             reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    ELSE            reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)
    RPAREN          reduce using rule 23 (functioncall -> ID LPAREN explist RPAREN .)


state 65

    (14) command -> WHILE exp DO block . END

    END             shift and go to state 85


state 66

    (35) exp -> exp PLUS exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 35 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 35 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 35 (exp -> exp PLUS exp .)
    AND             reduce using rule 35 (exp -> exp PLUS exp .)
    OR              reduce using rule 35 (exp -> exp PLUS exp .)
    LESS            reduce using rule 35 (exp -> exp PLUS exp .)
    LESSEQUAL       reduce using rule 35 (exp -> exp PLUS exp .)
    GREATER         reduce using rule 35 (exp -> exp PLUS exp .)
    GREATEREQUAL    reduce using rule 35 (exp -> exp PLUS exp .)
    EQUAL           reduce using rule 35 (exp -> exp PLUS exp .)
    NOTEQUAL        reduce using rule 35 (exp -> exp PLUS exp .)
    THEN            reduce using rule 35 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 35 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 35 (exp -> exp PLUS exp .)
    ID              reduce using rule 35 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 35 (exp -> exp PLUS exp .)
    IF              reduce using rule 35 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 35 (exp -> exp PLUS exp .)
    VAR             reduce using rule 35 (exp -> exp PLUS exp .)
    LOCAL           reduce using rule 35 (exp -> exp PLUS exp .)
    $end            reduce using rule 35 (exp -> exp PLUS exp .)
    END             reduce using rule 35 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 35 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 35 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! TIMES           [ reduce using rule 35 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 35 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 35 (exp -> exp PLUS exp .) ]
  ! CONCAT          [ reduce using rule 35 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 67

    (36) exp -> exp MINUS exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 36 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 36 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 36 (exp -> exp MINUS exp .)
    AND             reduce using rule 36 (exp -> exp MINUS exp .)
    OR              reduce using rule 36 (exp -> exp MINUS exp .)
    LESS            reduce using rule 36 (exp -> exp MINUS exp .)
    LESSEQUAL       reduce using rule 36 (exp -> exp MINUS exp .)
    GREATER         reduce using rule 36 (exp -> exp MINUS exp .)
    GREATEREQUAL    reduce using rule 36 (exp -> exp MINUS exp .)
    EQUAL           reduce using rule 36 (exp -> exp MINUS exp .)
    NOTEQUAL        reduce using rule 36 (exp -> exp MINUS exp .)
    THEN            reduce using rule 36 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 36 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 36 (exp -> exp MINUS exp .)
    ID              reduce using rule 36 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 36 (exp -> exp MINUS exp .)
    IF              reduce using rule 36 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 36 (exp -> exp MINUS exp .)
    VAR             reduce using rule 36 (exp -> exp MINUS exp .)
    LOCAL           reduce using rule 36 (exp -> exp MINUS exp .)
    $end            reduce using rule 36 (exp -> exp MINUS exp .)
    END             reduce using rule 36 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 36 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 36 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! TIMES           [ reduce using rule 36 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 36 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 36 (exp -> exp MINUS exp .) ]
  ! CONCAT          [ reduce using rule 36 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 68

    (37) exp -> exp TIMES exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 37 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 37 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 37 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 37 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 37 (exp -> exp TIMES exp .)
    AND             reduce using rule 37 (exp -> exp TIMES exp .)
    OR              reduce using rule 37 (exp -> exp TIMES exp .)
    LESS            reduce using rule 37 (exp -> exp TIMES exp .)
    LESSEQUAL       reduce using rule 37 (exp -> exp TIMES exp .)
    GREATER         reduce using rule 37 (exp -> exp TIMES exp .)
    GREATEREQUAL    reduce using rule 37 (exp -> exp TIMES exp .)
    EQUAL           reduce using rule 37 (exp -> exp TIMES exp .)
    NOTEQUAL        reduce using rule 37 (exp -> exp TIMES exp .)
    THEN            reduce using rule 37 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 37 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 37 (exp -> exp TIMES exp .)
    ID              reduce using rule 37 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 37 (exp -> exp TIMES exp .)
    IF              reduce using rule 37 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 37 (exp -> exp TIMES exp .)
    VAR             reduce using rule 37 (exp -> exp TIMES exp .)
    LOCAL           reduce using rule 37 (exp -> exp TIMES exp .)
    $end            reduce using rule 37 (exp -> exp TIMES exp .)
    END             reduce using rule 37 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 37 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 37 (exp -> exp TIMES exp .)
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! MOD             [ reduce using rule 37 (exp -> exp TIMES exp .) ]
  ! CONCAT          [ reduce using rule 37 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 69

    (38) exp -> exp DIVIDE exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 38 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 38 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 38 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 38 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 38 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 38 (exp -> exp DIVIDE exp .)
    OR              reduce using rule 38 (exp -> exp DIVIDE exp .)
    LESS            reduce using rule 38 (exp -> exp DIVIDE exp .)
    LESSEQUAL       reduce using rule 38 (exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 38 (exp -> exp DIVIDE exp .)
    GREATEREQUAL    reduce using rule 38 (exp -> exp DIVIDE exp .)
    EQUAL           reduce using rule 38 (exp -> exp DIVIDE exp .)
    NOTEQUAL        reduce using rule 38 (exp -> exp DIVIDE exp .)
    THEN            reduce using rule 38 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 38 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 38 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 38 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 38 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 38 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 38 (exp -> exp DIVIDE exp .)
    VAR             reduce using rule 38 (exp -> exp DIVIDE exp .)
    LOCAL           reduce using rule 38 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 38 (exp -> exp DIVIDE exp .)
    END             reduce using rule 38 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 38 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 38 (exp -> exp DIVIDE exp .)
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! MOD             [ reduce using rule 38 (exp -> exp DIVIDE exp .) ]
  ! CONCAT          [ reduce using rule 38 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 70

    (39) exp -> exp MOD exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 39 (exp -> exp MOD exp .)
    PLUS            reduce using rule 39 (exp -> exp MOD exp .)
    MINUS           reduce using rule 39 (exp -> exp MOD exp .)
    TIMES           reduce using rule 39 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 39 (exp -> exp MOD exp .)
    MOD             reduce using rule 39 (exp -> exp MOD exp .)
    AND             reduce using rule 39 (exp -> exp MOD exp .)
    OR              reduce using rule 39 (exp -> exp MOD exp .)
    LESS            reduce using rule 39 (exp -> exp MOD exp .)
    LESSEQUAL       reduce using rule 39 (exp -> exp MOD exp .)
    GREATER         reduce using rule 39 (exp -> exp MOD exp .)
    GREATEREQUAL    reduce using rule 39 (exp -> exp MOD exp .)
    EQUAL           reduce using rule 39 (exp -> exp MOD exp .)
    NOTEQUAL        reduce using rule 39 (exp -> exp MOD exp .)
    CONCAT          reduce using rule 39 (exp -> exp MOD exp .)
    THEN            reduce using rule 39 (exp -> exp MOD exp .)
    COMMA           reduce using rule 39 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 39 (exp -> exp MOD exp .)
    ID              reduce using rule 39 (exp -> exp MOD exp .)
    WHILE           reduce using rule 39 (exp -> exp MOD exp .)
    IF              reduce using rule 39 (exp -> exp MOD exp .)
    RETURN          reduce using rule 39 (exp -> exp MOD exp .)
    VAR             reduce using rule 39 (exp -> exp MOD exp .)
    LOCAL           reduce using rule 39 (exp -> exp MOD exp .)
    $end            reduce using rule 39 (exp -> exp MOD exp .)
    END             reduce using rule 39 (exp -> exp MOD exp .)
    ELSE            reduce using rule 39 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 39 (exp -> exp MOD exp .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! MOD             [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]
  ! CONCAT          [ shift and go to state 53 ]


state 71

    (40) exp -> exp AND exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 40 (exp -> exp AND exp .)
    AND             reduce using rule 40 (exp -> exp AND exp .)
    OR              reduce using rule 40 (exp -> exp AND exp .)
    THEN            reduce using rule 40 (exp -> exp AND exp .)
    COMMA           reduce using rule 40 (exp -> exp AND exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp AND exp .)
    ID              reduce using rule 40 (exp -> exp AND exp .)
    WHILE           reduce using rule 40 (exp -> exp AND exp .)
    IF              reduce using rule 40 (exp -> exp AND exp .)
    RETURN          reduce using rule 40 (exp -> exp AND exp .)
    VAR             reduce using rule 40 (exp -> exp AND exp .)
    LOCAL           reduce using rule 40 (exp -> exp AND exp .)
    $end            reduce using rule 40 (exp -> exp AND exp .)
    END             reduce using rule 40 (exp -> exp AND exp .)
    ELSE            reduce using rule 40 (exp -> exp AND exp .)
    RPAREN          reduce using rule 40 (exp -> exp AND exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! LESSEQUAL       [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! GREATEREQUAL    [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! EQUAL           [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! NOTEQUAL        [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! CONCAT          [ reduce using rule 40 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]


state 72

    (41) exp -> exp OR exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 41 (exp -> exp OR exp .)
    AND             reduce using rule 41 (exp -> exp OR exp .)
    OR              reduce using rule 41 (exp -> exp OR exp .)
    THEN            reduce using rule 41 (exp -> exp OR exp .)
    COMMA           reduce using rule 41 (exp -> exp OR exp .)
    SEMICOLON       reduce using rule 41 (exp -> exp OR exp .)
    ID              reduce using rule 41 (exp -> exp OR exp .)
    WHILE           reduce using rule 41 (exp -> exp OR exp .)
    IF              reduce using rule 41 (exp -> exp OR exp .)
    RETURN          reduce using rule 41 (exp -> exp OR exp .)
    VAR             reduce using rule 41 (exp -> exp OR exp .)
    LOCAL           reduce using rule 41 (exp -> exp OR exp .)
    $end            reduce using rule 41 (exp -> exp OR exp .)
    END             reduce using rule 41 (exp -> exp OR exp .)
    ELSE            reduce using rule 41 (exp -> exp OR exp .)
    RPAREN          reduce using rule 41 (exp -> exp OR exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! LESSEQUAL       [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! GREATEREQUAL    [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! EQUAL           [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! NOTEQUAL        [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! CONCAT          [ reduce using rule 41 (exp -> exp OR exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]


state 73

    (42) exp -> exp LESS exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 42 (exp -> exp LESS exp .)
    AND             reduce using rule 42 (exp -> exp LESS exp .)
    OR              reduce using rule 42 (exp -> exp LESS exp .)
    LESS            reduce using rule 42 (exp -> exp LESS exp .)
    LESSEQUAL       reduce using rule 42 (exp -> exp LESS exp .)
    GREATER         reduce using rule 42 (exp -> exp LESS exp .)
    GREATEREQUAL    reduce using rule 42 (exp -> exp LESS exp .)
    EQUAL           reduce using rule 42 (exp -> exp LESS exp .)
    NOTEQUAL        reduce using rule 42 (exp -> exp LESS exp .)
    THEN            reduce using rule 42 (exp -> exp LESS exp .)
    COMMA           reduce using rule 42 (exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp LESS exp .)
    ID              reduce using rule 42 (exp -> exp LESS exp .)
    WHILE           reduce using rule 42 (exp -> exp LESS exp .)
    IF              reduce using rule 42 (exp -> exp LESS exp .)
    RETURN          reduce using rule 42 (exp -> exp LESS exp .)
    VAR             reduce using rule 42 (exp -> exp LESS exp .)
    LOCAL           reduce using rule 42 (exp -> exp LESS exp .)
    $end            reduce using rule 42 (exp -> exp LESS exp .)
    END             reduce using rule 42 (exp -> exp LESS exp .)
    ELSE            reduce using rule 42 (exp -> exp LESS exp .)
    RPAREN          reduce using rule 42 (exp -> exp LESS exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! CONCAT          [ reduce using rule 42 (exp -> exp LESS exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 74

    (43) exp -> exp LESSEQUAL exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    AND             reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    OR              reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    LESS            reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    LESSEQUAL       reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    GREATER         reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    GREATEREQUAL    reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    EQUAL           reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    NOTEQUAL        reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    THEN            reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    COMMA           reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    ID              reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    WHILE           reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    IF              reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    RETURN          reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    VAR             reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    LOCAL           reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    $end            reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    END             reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    ELSE            reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    RPAREN          reduce using rule 43 (exp -> exp LESSEQUAL exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! TIMES           [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! CONCAT          [ reduce using rule 43 (exp -> exp LESSEQUAL exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 75

    (44) exp -> exp GREATER exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 44 (exp -> exp GREATER exp .)
    AND             reduce using rule 44 (exp -> exp GREATER exp .)
    OR              reduce using rule 44 (exp -> exp GREATER exp .)
    LESS            reduce using rule 44 (exp -> exp GREATER exp .)
    LESSEQUAL       reduce using rule 44 (exp -> exp GREATER exp .)
    GREATER         reduce using rule 44 (exp -> exp GREATER exp .)
    GREATEREQUAL    reduce using rule 44 (exp -> exp GREATER exp .)
    EQUAL           reduce using rule 44 (exp -> exp GREATER exp .)
    NOTEQUAL        reduce using rule 44 (exp -> exp GREATER exp .)
    THEN            reduce using rule 44 (exp -> exp GREATER exp .)
    COMMA           reduce using rule 44 (exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 44 (exp -> exp GREATER exp .)
    ID              reduce using rule 44 (exp -> exp GREATER exp .)
    WHILE           reduce using rule 44 (exp -> exp GREATER exp .)
    IF              reduce using rule 44 (exp -> exp GREATER exp .)
    RETURN          reduce using rule 44 (exp -> exp GREATER exp .)
    VAR             reduce using rule 44 (exp -> exp GREATER exp .)
    LOCAL           reduce using rule 44 (exp -> exp GREATER exp .)
    $end            reduce using rule 44 (exp -> exp GREATER exp .)
    END             reduce using rule 44 (exp -> exp GREATER exp .)
    ELSE            reduce using rule 44 (exp -> exp GREATER exp .)
    RPAREN          reduce using rule 44 (exp -> exp GREATER exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! CONCAT          [ reduce using rule 44 (exp -> exp GREATER exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 76

    (45) exp -> exp GREATEREQUAL exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    AND             reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    OR              reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    LESS            reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    LESSEQUAL       reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    GREATER         reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    GREATEREQUAL    reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    EQUAL           reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    NOTEQUAL        reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    THEN            reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    COMMA           reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    ID              reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    WHILE           reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    IF              reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    RETURN          reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    VAR             reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    LOCAL           reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    $end            reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    END             reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    ELSE            reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    RPAREN          reduce using rule 45 (exp -> exp GREATEREQUAL exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! TIMES           [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! CONCAT          [ reduce using rule 45 (exp -> exp GREATEREQUAL exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 77

    (46) exp -> exp EQUAL exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 46 (exp -> exp EQUAL exp .)
    AND             reduce using rule 46 (exp -> exp EQUAL exp .)
    OR              reduce using rule 46 (exp -> exp EQUAL exp .)
    EQUAL           reduce using rule 46 (exp -> exp EQUAL exp .)
    NOTEQUAL        reduce using rule 46 (exp -> exp EQUAL exp .)
    THEN            reduce using rule 46 (exp -> exp EQUAL exp .)
    COMMA           reduce using rule 46 (exp -> exp EQUAL exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp EQUAL exp .)
    ID              reduce using rule 46 (exp -> exp EQUAL exp .)
    WHILE           reduce using rule 46 (exp -> exp EQUAL exp .)
    IF              reduce using rule 46 (exp -> exp EQUAL exp .)
    RETURN          reduce using rule 46 (exp -> exp EQUAL exp .)
    VAR             reduce using rule 46 (exp -> exp EQUAL exp .)
    LOCAL           reduce using rule 46 (exp -> exp EQUAL exp .)
    $end            reduce using rule 46 (exp -> exp EQUAL exp .)
    END             reduce using rule 46 (exp -> exp EQUAL exp .)
    ELSE            reduce using rule 46 (exp -> exp EQUAL exp .)
    RPAREN          reduce using rule 46 (exp -> exp EQUAL exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! TIMES           [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! LESS            [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! GREATER         [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! GREATEREQUAL    [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! CONCAT          [ reduce using rule 46 (exp -> exp EQUAL exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 78

    (47) exp -> exp NOTEQUAL exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    AND             reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    OR              reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    EQUAL           reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    NOTEQUAL        reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    THEN            reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    COMMA           reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    SEMICOLON       reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    ID              reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    WHILE           reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    IF              reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    RETURN          reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    VAR             reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    LOCAL           reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    $end            reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    END             reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    ELSE            reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    RPAREN          reduce using rule 47 (exp -> exp NOTEQUAL exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    CONCAT          shift and go to state 53

  ! PLUS            [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! TIMES           [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! LESS            [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! GREATER         [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! GREATEREQUAL    [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! CONCAT          [ reduce using rule 47 (exp -> exp NOTEQUAL exp .) ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]


state 79

    (48) exp -> exp CONCAT exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    DO              reduce using rule 48 (exp -> exp CONCAT exp .)
    PLUS            reduce using rule 48 (exp -> exp CONCAT exp .)
    MINUS           reduce using rule 48 (exp -> exp CONCAT exp .)
    TIMES           reduce using rule 48 (exp -> exp CONCAT exp .)
    DIVIDE          reduce using rule 48 (exp -> exp CONCAT exp .)
    MOD             reduce using rule 48 (exp -> exp CONCAT exp .)
    AND             reduce using rule 48 (exp -> exp CONCAT exp .)
    OR              reduce using rule 48 (exp -> exp CONCAT exp .)
    LESS            reduce using rule 48 (exp -> exp CONCAT exp .)
    LESSEQUAL       reduce using rule 48 (exp -> exp CONCAT exp .)
    GREATER         reduce using rule 48 (exp -> exp CONCAT exp .)
    GREATEREQUAL    reduce using rule 48 (exp -> exp CONCAT exp .)
    EQUAL           reduce using rule 48 (exp -> exp CONCAT exp .)
    NOTEQUAL        reduce using rule 48 (exp -> exp CONCAT exp .)
    CONCAT          reduce using rule 48 (exp -> exp CONCAT exp .)
    THEN            reduce using rule 48 (exp -> exp CONCAT exp .)
    COMMA           reduce using rule 48 (exp -> exp CONCAT exp .)
    SEMICOLON       reduce using rule 48 (exp -> exp CONCAT exp .)
    ID              reduce using rule 48 (exp -> exp CONCAT exp .)
    WHILE           reduce using rule 48 (exp -> exp CONCAT exp .)
    IF              reduce using rule 48 (exp -> exp CONCAT exp .)
    RETURN          reduce using rule 48 (exp -> exp CONCAT exp .)
    VAR             reduce using rule 48 (exp -> exp CONCAT exp .)
    LOCAL           reduce using rule 48 (exp -> exp CONCAT exp .)
    $end            reduce using rule 48 (exp -> exp CONCAT exp .)
    END             reduce using rule 48 (exp -> exp CONCAT exp .)
    ELSE            reduce using rule 48 (exp -> exp CONCAT exp .)
    RPAREN          reduce using rule 48 (exp -> exp CONCAT exp .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! MOD             [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]
  ! LESS            [ shift and go to state 47 ]
  ! LESSEQUAL       [ shift and go to state 48 ]
  ! GREATER         [ shift and go to state 49 ]
  ! GREATEREQUAL    [ shift and go to state 50 ]
  ! EQUAL           [ shift and go to state 51 ]
  ! NOTEQUAL        [ shift and go to state 52 ]
  ! CONCAT          [ shift and go to state 53 ]


state 80

    (15) command -> IF exp THEN block . elsestnt END
    (51) elsestnt -> . empty
    (52) elsestnt -> . ELSE block
    (1) empty -> .

    ELSE            shift and go to state 88
    END             reduce using rule 1 (empty -> .)

    elsestnt                       shift and go to state 86
    empty                          shift and go to state 87

state 81

    (30) explist -> exp COMMA explist .

    SEMICOLON       reduce using rule 30 (explist -> exp COMMA explist .)
    ID              reduce using rule 30 (explist -> exp COMMA explist .)
    WHILE           reduce using rule 30 (explist -> exp COMMA explist .)
    IF              reduce using rule 30 (explist -> exp COMMA explist .)
    RETURN          reduce using rule 30 (explist -> exp COMMA explist .)
    VAR             reduce using rule 30 (explist -> exp COMMA explist .)
    LOCAL           reduce using rule 30 (explist -> exp COMMA explist .)
    $end            reduce using rule 30 (explist -> exp COMMA explist .)
    END             reduce using rule 30 (explist -> exp COMMA explist .)
    ELSE            reduce using rule 30 (explist -> exp COMMA explist .)
    RPAREN          reduce using rule 30 (explist -> exp COMMA explist .)


state 82

    (17) expassign -> ASSIGN exp .
    (35) exp -> exp . PLUS exp
    (36) exp -> exp . MINUS exp
    (37) exp -> exp . TIMES exp
    (38) exp -> exp . DIVIDE exp
    (39) exp -> exp . MOD exp
    (40) exp -> exp . AND exp
    (41) exp -> exp . OR exp
    (42) exp -> exp . LESS exp
    (43) exp -> exp . LESSEQUAL exp
    (44) exp -> exp . GREATER exp
    (45) exp -> exp . GREATEREQUAL exp
    (46) exp -> exp . EQUAL exp
    (47) exp -> exp . NOTEQUAL exp
    (48) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 17 (expassign -> ASSIGN exp .)
    ID              reduce using rule 17 (expassign -> ASSIGN exp .)
    WHILE           reduce using rule 17 (expassign -> ASSIGN exp .)
    IF              reduce using rule 17 (expassign -> ASSIGN exp .)
    RETURN          reduce using rule 17 (expassign -> ASSIGN exp .)
    VAR             reduce using rule 17 (expassign -> ASSIGN exp .)
    LOCAL           reduce using rule 17 (expassign -> ASSIGN exp .)
    $end            reduce using rule 17 (expassign -> ASSIGN exp .)
    END             reduce using rule 17 (expassign -> ASSIGN exp .)
    ELSE            reduce using rule 17 (expassign -> ASSIGN exp .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    MOD             shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46
    LESS            shift and go to state 47
    LESSEQUAL       shift and go to state 48
    GREATER         shift and go to state 49
    GREATEREQUAL    shift and go to state 50
    EQUAL           shift and go to state 51
    NOTEQUAL        shift and go to state 52
    CONCAT          shift and go to state 53


state 83

    (20) varassignmultiple -> LOCAL ID COMMA ID . ASSIGN functioncall

    ASSIGN          shift and go to state 89


state 84

    (22) functiondeclaration -> LOCAL FUNCTION ID LPAREN . paramlist RPAREN block END
    (24) paramlist -> . empty
    (25) paramlist -> . paramseq
    (1) empty -> .
    (26) paramseq -> . ID
    (27) paramseq -> . ID COMMA paramseq

    RPAREN          reduce using rule 1 (empty -> .)
    ID              shift and go to state 90

    paramlist                      shift and go to state 91
    empty                          shift and go to state 92
    paramseq                       shift and go to state 93

state 85

    (14) command -> WHILE exp DO block END .

    SEMICOLON       reduce using rule 14 (command -> WHILE exp DO block END .)
    ID              reduce using rule 14 (command -> WHILE exp DO block END .)
    WHILE           reduce using rule 14 (command -> WHILE exp DO block END .)
    IF              reduce using rule 14 (command -> WHILE exp DO block END .)
    RETURN          reduce using rule 14 (command -> WHILE exp DO block END .)
    VAR             reduce using rule 14 (command -> WHILE exp DO block END .)
    LOCAL           reduce using rule 14 (command -> WHILE exp DO block END .)
    $end            reduce using rule 14 (command -> WHILE exp DO block END .)
    END             reduce using rule 14 (command -> WHILE exp DO block END .)
    ELSE            reduce using rule 14 (command -> WHILE exp DO block END .)


state 86

    (15) command -> IF exp THEN block elsestnt . END

    END             shift and go to state 94


state 87

    (51) elsestnt -> empty .

    END             reduce using rule 51 (elsestnt -> empty .)


state 88

    (52) elsestnt -> ELSE . block
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    block                          shift and go to state 95
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 89

    (20) varassignmultiple -> LOCAL ID COMMA ID ASSIGN . functioncall
    (23) functioncall -> . ID LPAREN explist RPAREN

    ID              shift and go to state 96

    functioncall                   shift and go to state 97

state 90

    (26) paramseq -> ID .
    (27) paramseq -> ID . COMMA paramseq

    RPAREN          reduce using rule 26 (paramseq -> ID .)
    COMMA           shift and go to state 98


state 91

    (22) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist . RPAREN block END

    RPAREN          shift and go to state 99


state 92

    (24) paramlist -> empty .

    RPAREN          reduce using rule 24 (paramlist -> empty .)


state 93

    (25) paramlist -> paramseq .

    RPAREN          reduce using rule 25 (paramlist -> paramseq .)


state 94

    (15) command -> IF exp THEN block elsestnt END .

    SEMICOLON       reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    ID              reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    WHILE           reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    IF              reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    RETURN          reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    VAR             reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    LOCAL           reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    $end            reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    END             reduce using rule 15 (command -> IF exp THEN block elsestnt END .)
    ELSE            reduce using rule 15 (command -> IF exp THEN block elsestnt END .)


state 95

    (52) elsestnt -> ELSE block .

    END             reduce using rule 52 (elsestnt -> ELSE block .)


state 96

    (23) functioncall -> ID . LPAREN explist RPAREN

    LPAREN          shift and go to state 21


state 97

    (20) varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .

    SEMICOLON       reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    ID              reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    WHILE           reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    IF              reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    RETURN          reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    VAR             reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    LOCAL           reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    $end            reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    END             reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)
    ELSE            reduce using rule 20 (varassignmultiple -> LOCAL ID COMMA ID ASSIGN functioncall .)


state 98

    (27) paramseq -> ID COMMA . paramseq
    (26) paramseq -> . ID
    (27) paramseq -> . ID COMMA paramseq

    ID              shift and go to state 90

    paramseq                       shift and go to state 100

state 99

    (22) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN . block END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . varassignmultiple
    (14) command -> . WHILE exp DO block END
    (15) command -> . IF exp THEN block elsestnt END
    (16) command -> . RETURN explist
    (1) empty -> .
    (23) functioncall -> . ID LPAREN explist RPAREN
    (21) vardeclaration -> . VAR ID expassign
    (19) localdeclaration -> . LOCAL ID expassign
    (22) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
    (20) varassignmultiple -> . LOCAL ID COMMA ID ASSIGN functioncall

    ID              shift and go to state 6
    WHILE           shift and go to state 12
    IF              shift and go to state 13
    RETURN          shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 15
    LOCAL           shift and go to state 16

    block                          shift and go to state 101
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10
    varassignmultiple              shift and go to state 11

state 100

    (27) paramseq -> ID COMMA paramseq .

    RPAREN          reduce using rule 27 (paramseq -> ID COMMA paramseq .)


state 101

    (22) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block . END

    END             shift and go to state 102


state 102

    (22) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .

    SEMICOLON       reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    ID              reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    WHILE           reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    IF              reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    RETURN          reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    VAR             reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    LOCAL           reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    $end            reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    END             reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    ELSE            reduce using rule 22 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 14 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
