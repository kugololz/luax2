Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> block
Rule 3     block -> blocklist
Rule 4     blocklist -> command blockterminator blocklist
Rule 5     blocklist -> empty
Rule 6     blockterminator -> empty
Rule 7     blockterminator -> SEMICOLON
Rule 8     command -> ID ASSIGN exp
Rule 9     command -> functioncall
Rule 10    command -> vardeclaration
Rule 11    command -> localdeclaration
Rule 12    command -> functiondeclaration
Rule 13    command -> WHILE exp DO block END
Rule 14    command -> IF exp THEN block elsestnt END
Rule 15    command -> RETURN exp
Rule 16    localdeclaration -> LOCAL ID expassign
Rule 17    vardeclaration -> VAR ID expassign
Rule 18    expassign -> empty
Rule 19    expassign -> ASSIGN exp
Rule 20    functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END
Rule 21    functioncall -> ID LPAREN explist RPAREN
Rule 22    paramlist -> empty
Rule 23    paramlist -> paramseq
Rule 24    paramseq -> ID
Rule 25    paramseq -> ID COMMA paramseq
Rule 26    explist -> empty
Rule 27    explist -> exp
Rule 28    explist -> exp COMMA explist
Rule 29    exp -> NUMBER
Rule 30    exp -> ID
Rule 31    exp -> STRING
Rule 32    exp -> functioncall
Rule 33    exp -> exp PLUS exp
Rule 34    exp -> exp MINUS exp
Rule 35    exp -> exp TIMES exp
Rule 36    exp -> exp DIVIDE exp
Rule 37    exp -> exp MOD exp
Rule 38    exp -> exp AND exp
Rule 39    exp -> exp OR exp
Rule 40    exp -> exp LESS exp
Rule 41    exp -> exp LESSEQUAL exp
Rule 42    exp -> exp GREATER exp
Rule 43    exp -> exp GREATEREQUAL exp
Rule 44    exp -> exp EQUAL exp
Rule 45    exp -> exp NOTEQUAL exp
Rule 46    exp -> exp CONCAT exp
Rule 47    exp -> NOT exp
Rule 48    exp -> MINUS exp
Rule 49    elsestnt -> empty
Rule 50    elsestnt -> ELSE block

Terminals, with rules where they appear

AND                  : 38
ASSIGN               : 8 19
COMMA                : 25 28
CONCAT               : 46
DIVIDE               : 36
DO                   : 13
ELSE                 : 50
END                  : 13 14 20
EQUAL                : 44
FUNCTION             : 20
GREATER              : 42
GREATEREQUAL         : 43
ID                   : 8 16 17 20 21 24 25 30
IF                   : 14
LESS                 : 40
LESSEQUAL            : 41
LOCAL                : 16 20
LPAREN               : 20 21
MINUS                : 34 48
MOD                  : 37
NOT                  : 47
NOTEQUAL             : 45
NUMBER               : 29
OR                   : 39
PLUS                 : 33
RETURN               : 15
RPAREN               : 20 21
SEMICOLON            : 7
STRING               : 31
THEN                 : 14
TIMES                : 35
VAR                  : 17
WHILE                : 13
error                : 

Nonterminals, with rules where they appear

block                : 2 13 14 20 50
blocklist            : 3 4
blockterminator      : 4
command              : 4
elsestnt             : 14
empty                : 5 6 18 22 26 49
exp                  : 8 13 14 15 19 27 28 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 48
expassign            : 16 17
explist              : 21 28
functioncall         : 9 32
functiondeclaration  : 12
localdeclaration     : 11
paramlist            : 20
paramseq             : 23 25
program              : 0
vardeclaration       : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . block
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    $end            reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    program                        shift and go to state 1
    block                          shift and go to state 2
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (2) program -> block .

    $end            reduce using rule 2 (program -> block .)


state 3

    (3) block -> blocklist .

    $end            reduce using rule 3 (block -> blocklist .)
    END             reduce using rule 3 (block -> blocklist .)
    ELSE            reduce using rule 3 (block -> blocklist .)


state 4

    (4) blocklist -> command . blockterminator blocklist
    (6) blockterminator -> . empty
    (7) blockterminator -> . SEMICOLON
    (1) empty -> .

    SEMICOLON       shift and go to state 18
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    blockterminator                shift and go to state 16
    empty                          shift and go to state 17

state 5

    (5) blocklist -> empty .

    $end            reduce using rule 5 (blocklist -> empty .)
    END             reduce using rule 5 (blocklist -> empty .)
    ELSE            reduce using rule 5 (blocklist -> empty .)


state 6

    (8) command -> ID . ASSIGN exp
    (21) functioncall -> ID . LPAREN explist RPAREN

    ASSIGN          shift and go to state 19
    LPAREN          shift and go to state 20


state 7

    (9) command -> functioncall .

    SEMICOLON       reduce using rule 9 (command -> functioncall .)
    ID              reduce using rule 9 (command -> functioncall .)
    WHILE           reduce using rule 9 (command -> functioncall .)
    IF              reduce using rule 9 (command -> functioncall .)
    RETURN          reduce using rule 9 (command -> functioncall .)
    VAR             reduce using rule 9 (command -> functioncall .)
    LOCAL           reduce using rule 9 (command -> functioncall .)
    $end            reduce using rule 9 (command -> functioncall .)
    END             reduce using rule 9 (command -> functioncall .)
    ELSE            reduce using rule 9 (command -> functioncall .)


state 8

    (10) command -> vardeclaration .

    SEMICOLON       reduce using rule 10 (command -> vardeclaration .)
    ID              reduce using rule 10 (command -> vardeclaration .)
    WHILE           reduce using rule 10 (command -> vardeclaration .)
    IF              reduce using rule 10 (command -> vardeclaration .)
    RETURN          reduce using rule 10 (command -> vardeclaration .)
    VAR             reduce using rule 10 (command -> vardeclaration .)
    LOCAL           reduce using rule 10 (command -> vardeclaration .)
    $end            reduce using rule 10 (command -> vardeclaration .)
    END             reduce using rule 10 (command -> vardeclaration .)
    ELSE            reduce using rule 10 (command -> vardeclaration .)


state 9

    (11) command -> localdeclaration .

    SEMICOLON       reduce using rule 11 (command -> localdeclaration .)
    ID              reduce using rule 11 (command -> localdeclaration .)
    WHILE           reduce using rule 11 (command -> localdeclaration .)
    IF              reduce using rule 11 (command -> localdeclaration .)
    RETURN          reduce using rule 11 (command -> localdeclaration .)
    VAR             reduce using rule 11 (command -> localdeclaration .)
    LOCAL           reduce using rule 11 (command -> localdeclaration .)
    $end            reduce using rule 11 (command -> localdeclaration .)
    END             reduce using rule 11 (command -> localdeclaration .)
    ELSE            reduce using rule 11 (command -> localdeclaration .)


state 10

    (12) command -> functiondeclaration .

    SEMICOLON       reduce using rule 12 (command -> functiondeclaration .)
    ID              reduce using rule 12 (command -> functiondeclaration .)
    WHILE           reduce using rule 12 (command -> functiondeclaration .)
    IF              reduce using rule 12 (command -> functiondeclaration .)
    RETURN          reduce using rule 12 (command -> functiondeclaration .)
    VAR             reduce using rule 12 (command -> functiondeclaration .)
    LOCAL           reduce using rule 12 (command -> functiondeclaration .)
    $end            reduce using rule 12 (command -> functiondeclaration .)
    END             reduce using rule 12 (command -> functiondeclaration .)
    ELSE            reduce using rule 12 (command -> functiondeclaration .)


state 11

    (13) command -> WHILE . exp DO block END
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 21
    functioncall                   shift and go to state 25

state 12

    (14) command -> IF . exp THEN block elsestnt END
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 28
    functioncall                   shift and go to state 25

state 13

    (15) command -> RETURN . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 29
    functioncall                   shift and go to state 25

state 14

    (17) vardeclaration -> VAR . ID expassign

    ID              shift and go to state 30


state 15

    (16) localdeclaration -> LOCAL . ID expassign
    (20) functiondeclaration -> LOCAL . FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 31
    FUNCTION        shift and go to state 32


state 16

    (4) blocklist -> command blockterminator . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    command                        shift and go to state 4
    blocklist                      shift and go to state 33
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 17

    (6) blockterminator -> empty .

    ID              reduce using rule 6 (blockterminator -> empty .)
    WHILE           reduce using rule 6 (blockterminator -> empty .)
    IF              reduce using rule 6 (blockterminator -> empty .)
    RETURN          reduce using rule 6 (blockterminator -> empty .)
    VAR             reduce using rule 6 (blockterminator -> empty .)
    LOCAL           reduce using rule 6 (blockterminator -> empty .)
    $end            reduce using rule 6 (blockterminator -> empty .)
    END             reduce using rule 6 (blockterminator -> empty .)
    ELSE            reduce using rule 6 (blockterminator -> empty .)


state 18

    (7) blockterminator -> SEMICOLON .

    ID              reduce using rule 7 (blockterminator -> SEMICOLON .)
    WHILE           reduce using rule 7 (blockterminator -> SEMICOLON .)
    IF              reduce using rule 7 (blockterminator -> SEMICOLON .)
    RETURN          reduce using rule 7 (blockterminator -> SEMICOLON .)
    VAR             reduce using rule 7 (blockterminator -> SEMICOLON .)
    LOCAL           reduce using rule 7 (blockterminator -> SEMICOLON .)
    $end            reduce using rule 7 (blockterminator -> SEMICOLON .)
    END             reduce using rule 7 (blockterminator -> SEMICOLON .)
    ELSE            reduce using rule 7 (blockterminator -> SEMICOLON .)


state 19

    (8) command -> ID ASSIGN . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 34
    functioncall                   shift and go to state 25

state 20

    (21) functioncall -> ID LPAREN . explist RPAREN
    (26) explist -> . empty
    (27) explist -> . exp
    (28) explist -> . exp COMMA explist
    (1) empty -> .
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    RPAREN          reduce using rule 1 (empty -> .)
    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    explist                        shift and go to state 35
    empty                          shift and go to state 36
    exp                            shift and go to state 37
    functioncall                   shift and go to state 25

state 21

    (13) command -> WHILE exp . DO block END
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 22

    (29) exp -> NUMBER .

    DO              reduce using rule 29 (exp -> NUMBER .)
    PLUS            reduce using rule 29 (exp -> NUMBER .)
    MINUS           reduce using rule 29 (exp -> NUMBER .)
    TIMES           reduce using rule 29 (exp -> NUMBER .)
    DIVIDE          reduce using rule 29 (exp -> NUMBER .)
    MOD             reduce using rule 29 (exp -> NUMBER .)
    AND             reduce using rule 29 (exp -> NUMBER .)
    OR              reduce using rule 29 (exp -> NUMBER .)
    LESS            reduce using rule 29 (exp -> NUMBER .)
    LESSEQUAL       reduce using rule 29 (exp -> NUMBER .)
    GREATER         reduce using rule 29 (exp -> NUMBER .)
    GREATEREQUAL    reduce using rule 29 (exp -> NUMBER .)
    EQUAL           reduce using rule 29 (exp -> NUMBER .)
    NOTEQUAL        reduce using rule 29 (exp -> NUMBER .)
    CONCAT          reduce using rule 29 (exp -> NUMBER .)
    THEN            reduce using rule 29 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 29 (exp -> NUMBER .)
    ID              reduce using rule 29 (exp -> NUMBER .)
    WHILE           reduce using rule 29 (exp -> NUMBER .)
    IF              reduce using rule 29 (exp -> NUMBER .)
    RETURN          reduce using rule 29 (exp -> NUMBER .)
    VAR             reduce using rule 29 (exp -> NUMBER .)
    LOCAL           reduce using rule 29 (exp -> NUMBER .)
    $end            reduce using rule 29 (exp -> NUMBER .)
    END             reduce using rule 29 (exp -> NUMBER .)
    ELSE            reduce using rule 29 (exp -> NUMBER .)
    COMMA           reduce using rule 29 (exp -> NUMBER .)
    RPAREN          reduce using rule 29 (exp -> NUMBER .)


state 23

    (30) exp -> ID .
    (21) functioncall -> ID . LPAREN explist RPAREN

    DO              reduce using rule 30 (exp -> ID .)
    PLUS            reduce using rule 30 (exp -> ID .)
    MINUS           reduce using rule 30 (exp -> ID .)
    TIMES           reduce using rule 30 (exp -> ID .)
    DIVIDE          reduce using rule 30 (exp -> ID .)
    MOD             reduce using rule 30 (exp -> ID .)
    AND             reduce using rule 30 (exp -> ID .)
    OR              reduce using rule 30 (exp -> ID .)
    LESS            reduce using rule 30 (exp -> ID .)
    LESSEQUAL       reduce using rule 30 (exp -> ID .)
    GREATER         reduce using rule 30 (exp -> ID .)
    GREATEREQUAL    reduce using rule 30 (exp -> ID .)
    EQUAL           reduce using rule 30 (exp -> ID .)
    NOTEQUAL        reduce using rule 30 (exp -> ID .)
    CONCAT          reduce using rule 30 (exp -> ID .)
    THEN            reduce using rule 30 (exp -> ID .)
    SEMICOLON       reduce using rule 30 (exp -> ID .)
    ID              reduce using rule 30 (exp -> ID .)
    WHILE           reduce using rule 30 (exp -> ID .)
    IF              reduce using rule 30 (exp -> ID .)
    RETURN          reduce using rule 30 (exp -> ID .)
    VAR             reduce using rule 30 (exp -> ID .)
    LOCAL           reduce using rule 30 (exp -> ID .)
    $end            reduce using rule 30 (exp -> ID .)
    END             reduce using rule 30 (exp -> ID .)
    ELSE            reduce using rule 30 (exp -> ID .)
    COMMA           reduce using rule 30 (exp -> ID .)
    RPAREN          reduce using rule 30 (exp -> ID .)
    LPAREN          shift and go to state 20


state 24

    (31) exp -> STRING .

    DO              reduce using rule 31 (exp -> STRING .)
    PLUS            reduce using rule 31 (exp -> STRING .)
    MINUS           reduce using rule 31 (exp -> STRING .)
    TIMES           reduce using rule 31 (exp -> STRING .)
    DIVIDE          reduce using rule 31 (exp -> STRING .)
    MOD             reduce using rule 31 (exp -> STRING .)
    AND             reduce using rule 31 (exp -> STRING .)
    OR              reduce using rule 31 (exp -> STRING .)
    LESS            reduce using rule 31 (exp -> STRING .)
    LESSEQUAL       reduce using rule 31 (exp -> STRING .)
    GREATER         reduce using rule 31 (exp -> STRING .)
    GREATEREQUAL    reduce using rule 31 (exp -> STRING .)
    EQUAL           reduce using rule 31 (exp -> STRING .)
    NOTEQUAL        reduce using rule 31 (exp -> STRING .)
    CONCAT          reduce using rule 31 (exp -> STRING .)
    THEN            reduce using rule 31 (exp -> STRING .)
    SEMICOLON       reduce using rule 31 (exp -> STRING .)
    ID              reduce using rule 31 (exp -> STRING .)
    WHILE           reduce using rule 31 (exp -> STRING .)
    IF              reduce using rule 31 (exp -> STRING .)
    RETURN          reduce using rule 31 (exp -> STRING .)
    VAR             reduce using rule 31 (exp -> STRING .)
    LOCAL           reduce using rule 31 (exp -> STRING .)
    $end            reduce using rule 31 (exp -> STRING .)
    END             reduce using rule 31 (exp -> STRING .)
    ELSE            reduce using rule 31 (exp -> STRING .)
    COMMA           reduce using rule 31 (exp -> STRING .)
    RPAREN          reduce using rule 31 (exp -> STRING .)


state 25

    (32) exp -> functioncall .

    DO              reduce using rule 32 (exp -> functioncall .)
    PLUS            reduce using rule 32 (exp -> functioncall .)
    MINUS           reduce using rule 32 (exp -> functioncall .)
    TIMES           reduce using rule 32 (exp -> functioncall .)
    DIVIDE          reduce using rule 32 (exp -> functioncall .)
    MOD             reduce using rule 32 (exp -> functioncall .)
    AND             reduce using rule 32 (exp -> functioncall .)
    OR              reduce using rule 32 (exp -> functioncall .)
    LESS            reduce using rule 32 (exp -> functioncall .)
    LESSEQUAL       reduce using rule 32 (exp -> functioncall .)
    GREATER         reduce using rule 32 (exp -> functioncall .)
    GREATEREQUAL    reduce using rule 32 (exp -> functioncall .)
    EQUAL           reduce using rule 32 (exp -> functioncall .)
    NOTEQUAL        reduce using rule 32 (exp -> functioncall .)
    CONCAT          reduce using rule 32 (exp -> functioncall .)
    THEN            reduce using rule 32 (exp -> functioncall .)
    SEMICOLON       reduce using rule 32 (exp -> functioncall .)
    ID              reduce using rule 32 (exp -> functioncall .)
    WHILE           reduce using rule 32 (exp -> functioncall .)
    IF              reduce using rule 32 (exp -> functioncall .)
    RETURN          reduce using rule 32 (exp -> functioncall .)
    VAR             reduce using rule 32 (exp -> functioncall .)
    LOCAL           reduce using rule 32 (exp -> functioncall .)
    $end            reduce using rule 32 (exp -> functioncall .)
    END             reduce using rule 32 (exp -> functioncall .)
    ELSE            reduce using rule 32 (exp -> functioncall .)
    COMMA           reduce using rule 32 (exp -> functioncall .)
    RPAREN          reduce using rule 32 (exp -> functioncall .)


state 26

    (48) exp -> MINUS . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 53
    functioncall                   shift and go to state 25

state 27

    (47) exp -> NOT . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 54
    functioncall                   shift and go to state 25

state 28

    (14) command -> IF exp . THEN block elsestnt END
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    THEN            shift and go to state 55
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 29

    (15) command -> RETURN exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 15 (command -> RETURN exp .)
    ID              reduce using rule 15 (command -> RETURN exp .)
    WHILE           reduce using rule 15 (command -> RETURN exp .)
    IF              reduce using rule 15 (command -> RETURN exp .)
    RETURN          reduce using rule 15 (command -> RETURN exp .)
    VAR             reduce using rule 15 (command -> RETURN exp .)
    LOCAL           reduce using rule 15 (command -> RETURN exp .)
    $end            reduce using rule 15 (command -> RETURN exp .)
    END             reduce using rule 15 (command -> RETURN exp .)
    ELSE            reduce using rule 15 (command -> RETURN exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 30

    (17) vardeclaration -> VAR ID . expassign
    (18) expassign -> . empty
    (19) expassign -> . ASSIGN exp
    (1) empty -> .

    ASSIGN          shift and go to state 58
    SEMICOLON       reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    expassign                      shift and go to state 56
    empty                          shift and go to state 57

state 31

    (16) localdeclaration -> LOCAL ID . expassign
    (18) expassign -> . empty
    (19) expassign -> . ASSIGN exp
    (1) empty -> .

    ASSIGN          shift and go to state 58
    SEMICOLON       reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    VAR             reduce using rule 1 (empty -> .)
    LOCAL           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    expassign                      shift and go to state 59
    empty                          shift and go to state 57

state 32

    (20) functiondeclaration -> LOCAL FUNCTION . ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 60


state 33

    (4) blocklist -> command blockterminator blocklist .

    $end            reduce using rule 4 (blocklist -> command blockterminator blocklist .)
    END             reduce using rule 4 (blocklist -> command blockterminator blocklist .)
    ELSE            reduce using rule 4 (blocklist -> command blockterminator blocklist .)


state 34

    (8) command -> ID ASSIGN exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 8 (command -> ID ASSIGN exp .)
    ID              reduce using rule 8 (command -> ID ASSIGN exp .)
    WHILE           reduce using rule 8 (command -> ID ASSIGN exp .)
    IF              reduce using rule 8 (command -> ID ASSIGN exp .)
    RETURN          reduce using rule 8 (command -> ID ASSIGN exp .)
    VAR             reduce using rule 8 (command -> ID ASSIGN exp .)
    LOCAL           reduce using rule 8 (command -> ID ASSIGN exp .)
    $end            reduce using rule 8 (command -> ID ASSIGN exp .)
    END             reduce using rule 8 (command -> ID ASSIGN exp .)
    ELSE            reduce using rule 8 (command -> ID ASSIGN exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 35

    (21) functioncall -> ID LPAREN explist . RPAREN

    RPAREN          shift and go to state 61


state 36

    (26) explist -> empty .

    RPAREN          reduce using rule 26 (explist -> empty .)


state 37

    (27) explist -> exp .
    (28) explist -> exp . COMMA explist
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    RPAREN          reduce using rule 27 (explist -> exp .)
    COMMA           shift and go to state 62
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 38

    (13) command -> WHILE exp DO . block END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    block                          shift and go to state 63
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 39

    (33) exp -> exp PLUS . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 64
    functioncall                   shift and go to state 25

state 40

    (34) exp -> exp MINUS . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 65
    functioncall                   shift and go to state 25

state 41

    (35) exp -> exp TIMES . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 66
    functioncall                   shift and go to state 25

state 42

    (36) exp -> exp DIVIDE . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 67
    functioncall                   shift and go to state 25

state 43

    (37) exp -> exp MOD . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 68
    functioncall                   shift and go to state 25

state 44

    (38) exp -> exp AND . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 69
    functioncall                   shift and go to state 25

state 45

    (39) exp -> exp OR . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 70
    functioncall                   shift and go to state 25

state 46

    (40) exp -> exp LESS . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 71
    functioncall                   shift and go to state 25

state 47

    (41) exp -> exp LESSEQUAL . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 72
    functioncall                   shift and go to state 25

state 48

    (42) exp -> exp GREATER . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 73
    functioncall                   shift and go to state 25

state 49

    (43) exp -> exp GREATEREQUAL . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 74
    functioncall                   shift and go to state 25

state 50

    (44) exp -> exp EQUAL . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 75
    functioncall                   shift and go to state 25

state 51

    (45) exp -> exp NOTEQUAL . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 76
    functioncall                   shift and go to state 25

state 52

    (46) exp -> exp CONCAT . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 77
    functioncall                   shift and go to state 25

state 53

    (48) exp -> MINUS exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 48 (exp -> MINUS exp .)
    PLUS            reduce using rule 48 (exp -> MINUS exp .)
    MINUS           reduce using rule 48 (exp -> MINUS exp .)
    TIMES           reduce using rule 48 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 48 (exp -> MINUS exp .)
    MOD             reduce using rule 48 (exp -> MINUS exp .)
    AND             reduce using rule 48 (exp -> MINUS exp .)
    OR              reduce using rule 48 (exp -> MINUS exp .)
    LESS            reduce using rule 48 (exp -> MINUS exp .)
    LESSEQUAL       reduce using rule 48 (exp -> MINUS exp .)
    GREATER         reduce using rule 48 (exp -> MINUS exp .)
    GREATEREQUAL    reduce using rule 48 (exp -> MINUS exp .)
    EQUAL           reduce using rule 48 (exp -> MINUS exp .)
    NOTEQUAL        reduce using rule 48 (exp -> MINUS exp .)
    CONCAT          reduce using rule 48 (exp -> MINUS exp .)
    THEN            reduce using rule 48 (exp -> MINUS exp .)
    SEMICOLON       reduce using rule 48 (exp -> MINUS exp .)
    ID              reduce using rule 48 (exp -> MINUS exp .)
    WHILE           reduce using rule 48 (exp -> MINUS exp .)
    IF              reduce using rule 48 (exp -> MINUS exp .)
    RETURN          reduce using rule 48 (exp -> MINUS exp .)
    VAR             reduce using rule 48 (exp -> MINUS exp .)
    LOCAL           reduce using rule 48 (exp -> MINUS exp .)
    $end            reduce using rule 48 (exp -> MINUS exp .)
    END             reduce using rule 48 (exp -> MINUS exp .)
    ELSE            reduce using rule 48 (exp -> MINUS exp .)
    COMMA           reduce using rule 48 (exp -> MINUS exp .)
    RPAREN          reduce using rule 48 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! MOD             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]
  ! CONCAT          [ shift and go to state 52 ]


state 54

    (47) exp -> NOT exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 47 (exp -> NOT exp .)
    PLUS            reduce using rule 47 (exp -> NOT exp .)
    MINUS           reduce using rule 47 (exp -> NOT exp .)
    TIMES           reduce using rule 47 (exp -> NOT exp .)
    DIVIDE          reduce using rule 47 (exp -> NOT exp .)
    MOD             reduce using rule 47 (exp -> NOT exp .)
    AND             reduce using rule 47 (exp -> NOT exp .)
    OR              reduce using rule 47 (exp -> NOT exp .)
    LESS            reduce using rule 47 (exp -> NOT exp .)
    LESSEQUAL       reduce using rule 47 (exp -> NOT exp .)
    GREATER         reduce using rule 47 (exp -> NOT exp .)
    GREATEREQUAL    reduce using rule 47 (exp -> NOT exp .)
    EQUAL           reduce using rule 47 (exp -> NOT exp .)
    NOTEQUAL        reduce using rule 47 (exp -> NOT exp .)
    CONCAT          reduce using rule 47 (exp -> NOT exp .)
    THEN            reduce using rule 47 (exp -> NOT exp .)
    SEMICOLON       reduce using rule 47 (exp -> NOT exp .)
    ID              reduce using rule 47 (exp -> NOT exp .)
    WHILE           reduce using rule 47 (exp -> NOT exp .)
    IF              reduce using rule 47 (exp -> NOT exp .)
    RETURN          reduce using rule 47 (exp -> NOT exp .)
    VAR             reduce using rule 47 (exp -> NOT exp .)
    LOCAL           reduce using rule 47 (exp -> NOT exp .)
    $end            reduce using rule 47 (exp -> NOT exp .)
    END             reduce using rule 47 (exp -> NOT exp .)
    ELSE            reduce using rule 47 (exp -> NOT exp .)
    COMMA           reduce using rule 47 (exp -> NOT exp .)
    RPAREN          reduce using rule 47 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! MOD             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]
  ! CONCAT          [ shift and go to state 52 ]


state 55

    (14) command -> IF exp THEN . block elsestnt END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    ELSE            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    block                          shift and go to state 78
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 56

    (17) vardeclaration -> VAR ID expassign .

    SEMICOLON       reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    ID              reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    WHILE           reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    IF              reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    RETURN          reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    VAR             reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    LOCAL           reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    $end            reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    END             reduce using rule 17 (vardeclaration -> VAR ID expassign .)
    ELSE            reduce using rule 17 (vardeclaration -> VAR ID expassign .)


state 57

    (18) expassign -> empty .

    SEMICOLON       reduce using rule 18 (expassign -> empty .)
    ID              reduce using rule 18 (expassign -> empty .)
    WHILE           reduce using rule 18 (expassign -> empty .)
    IF              reduce using rule 18 (expassign -> empty .)
    RETURN          reduce using rule 18 (expassign -> empty .)
    VAR             reduce using rule 18 (expassign -> empty .)
    LOCAL           reduce using rule 18 (expassign -> empty .)
    $end            reduce using rule 18 (expassign -> empty .)
    END             reduce using rule 18 (expassign -> empty .)
    ELSE            reduce using rule 18 (expassign -> empty .)


state 58

    (19) expassign -> ASSIGN . exp
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 79
    functioncall                   shift and go to state 25

state 59

    (16) localdeclaration -> LOCAL ID expassign .

    SEMICOLON       reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    ID              reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    WHILE           reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    IF              reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    RETURN          reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    VAR             reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    LOCAL           reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    $end            reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    END             reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)
    ELSE            reduce using rule 16 (localdeclaration -> LOCAL ID expassign .)


state 60

    (20) functiondeclaration -> LOCAL FUNCTION ID . LPAREN paramlist RPAREN block END

    LPAREN          shift and go to state 80


state 61

    (21) functioncall -> ID LPAREN explist RPAREN .

    SEMICOLON       reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    ID              reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    WHILE           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    IF              reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    RETURN          reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    VAR             reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    LOCAL           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    $end            reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    DO              reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    PLUS            reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    MINUS           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    TIMES           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    DIVIDE          reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    MOD             reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    AND             reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    OR              reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    LESS            reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    LESSEQUAL       reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    GREATER         reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    GREATEREQUAL    reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    EQUAL           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    NOTEQUAL        reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    CONCAT          reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    THEN            reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    END             reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    ELSE            reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    COMMA           reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)
    RPAREN          reduce using rule 21 (functioncall -> ID LPAREN explist RPAREN .)


state 62

    (28) explist -> exp COMMA . explist
    (26) explist -> . empty
    (27) explist -> . exp
    (28) explist -> . exp COMMA explist
    (1) empty -> .
    (29) exp -> . NUMBER
    (30) exp -> . ID
    (31) exp -> . STRING
    (32) exp -> . functioncall
    (33) exp -> . exp PLUS exp
    (34) exp -> . exp MINUS exp
    (35) exp -> . exp TIMES exp
    (36) exp -> . exp DIVIDE exp
    (37) exp -> . exp MOD exp
    (38) exp -> . exp AND exp
    (39) exp -> . exp OR exp
    (40) exp -> . exp LESS exp
    (41) exp -> . exp LESSEQUAL exp
    (42) exp -> . exp GREATER exp
    (43) exp -> . exp GREATEREQUAL exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NOTEQUAL exp
    (46) exp -> . exp CONCAT exp
    (47) exp -> . NOT exp
    (48) exp -> . MINUS exp
    (21) functioncall -> . ID LPAREN explist RPAREN

    RPAREN          reduce using rule 1 (empty -> .)
    NUMBER          shift and go to state 22
    ID              shift and go to state 23
    STRING          shift and go to state 24
    NOT             shift and go to state 27
    MINUS           shift and go to state 26

    exp                            shift and go to state 37
    explist                        shift and go to state 81
    empty                          shift and go to state 36
    functioncall                   shift and go to state 25

state 63

    (13) command -> WHILE exp DO block . END

    END             shift and go to state 82


state 64

    (33) exp -> exp PLUS exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 33 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 33 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 33 (exp -> exp PLUS exp .)
    AND             reduce using rule 33 (exp -> exp PLUS exp .)
    OR              reduce using rule 33 (exp -> exp PLUS exp .)
    LESS            reduce using rule 33 (exp -> exp PLUS exp .)
    LESSEQUAL       reduce using rule 33 (exp -> exp PLUS exp .)
    GREATER         reduce using rule 33 (exp -> exp PLUS exp .)
    GREATEREQUAL    reduce using rule 33 (exp -> exp PLUS exp .)
    EQUAL           reduce using rule 33 (exp -> exp PLUS exp .)
    NOTEQUAL        reduce using rule 33 (exp -> exp PLUS exp .)
    THEN            reduce using rule 33 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 33 (exp -> exp PLUS exp .)
    ID              reduce using rule 33 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 33 (exp -> exp PLUS exp .)
    IF              reduce using rule 33 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 33 (exp -> exp PLUS exp .)
    VAR             reduce using rule 33 (exp -> exp PLUS exp .)
    LOCAL           reduce using rule 33 (exp -> exp PLUS exp .)
    $end            reduce using rule 33 (exp -> exp PLUS exp .)
    END             reduce using rule 33 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 33 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 33 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 33 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! TIMES           [ reduce using rule 33 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 33 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 33 (exp -> exp PLUS exp .) ]
  ! CONCAT          [ reduce using rule 33 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 65

    (34) exp -> exp MINUS exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 34 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 34 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 34 (exp -> exp MINUS exp .)
    AND             reduce using rule 34 (exp -> exp MINUS exp .)
    OR              reduce using rule 34 (exp -> exp MINUS exp .)
    LESS            reduce using rule 34 (exp -> exp MINUS exp .)
    LESSEQUAL       reduce using rule 34 (exp -> exp MINUS exp .)
    GREATER         reduce using rule 34 (exp -> exp MINUS exp .)
    GREATEREQUAL    reduce using rule 34 (exp -> exp MINUS exp .)
    EQUAL           reduce using rule 34 (exp -> exp MINUS exp .)
    NOTEQUAL        reduce using rule 34 (exp -> exp MINUS exp .)
    THEN            reduce using rule 34 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 34 (exp -> exp MINUS exp .)
    ID              reduce using rule 34 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 34 (exp -> exp MINUS exp .)
    IF              reduce using rule 34 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 34 (exp -> exp MINUS exp .)
    VAR             reduce using rule 34 (exp -> exp MINUS exp .)
    LOCAL           reduce using rule 34 (exp -> exp MINUS exp .)
    $end            reduce using rule 34 (exp -> exp MINUS exp .)
    END             reduce using rule 34 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 34 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 34 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 34 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! TIMES           [ reduce using rule 34 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 34 (exp -> exp MINUS exp .) ]
  ! CONCAT          [ reduce using rule 34 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 66

    (35) exp -> exp TIMES exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 35 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 35 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 35 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 35 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 35 (exp -> exp TIMES exp .)
    AND             reduce using rule 35 (exp -> exp TIMES exp .)
    OR              reduce using rule 35 (exp -> exp TIMES exp .)
    LESS            reduce using rule 35 (exp -> exp TIMES exp .)
    LESSEQUAL       reduce using rule 35 (exp -> exp TIMES exp .)
    GREATER         reduce using rule 35 (exp -> exp TIMES exp .)
    GREATEREQUAL    reduce using rule 35 (exp -> exp TIMES exp .)
    EQUAL           reduce using rule 35 (exp -> exp TIMES exp .)
    NOTEQUAL        reduce using rule 35 (exp -> exp TIMES exp .)
    THEN            reduce using rule 35 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 35 (exp -> exp TIMES exp .)
    ID              reduce using rule 35 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 35 (exp -> exp TIMES exp .)
    IF              reduce using rule 35 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 35 (exp -> exp TIMES exp .)
    VAR             reduce using rule 35 (exp -> exp TIMES exp .)
    LOCAL           reduce using rule 35 (exp -> exp TIMES exp .)
    $end            reduce using rule 35 (exp -> exp TIMES exp .)
    END             reduce using rule 35 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 35 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 35 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 35 (exp -> exp TIMES exp .)
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! MOD             [ reduce using rule 35 (exp -> exp TIMES exp .) ]
  ! CONCAT          [ reduce using rule 35 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 67

    (36) exp -> exp DIVIDE exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 36 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 36 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 36 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 36 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 36 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 36 (exp -> exp DIVIDE exp .)
    OR              reduce using rule 36 (exp -> exp DIVIDE exp .)
    LESS            reduce using rule 36 (exp -> exp DIVIDE exp .)
    LESSEQUAL       reduce using rule 36 (exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 36 (exp -> exp DIVIDE exp .)
    GREATEREQUAL    reduce using rule 36 (exp -> exp DIVIDE exp .)
    EQUAL           reduce using rule 36 (exp -> exp DIVIDE exp .)
    NOTEQUAL        reduce using rule 36 (exp -> exp DIVIDE exp .)
    THEN            reduce using rule 36 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 36 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 36 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 36 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 36 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 36 (exp -> exp DIVIDE exp .)
    VAR             reduce using rule 36 (exp -> exp DIVIDE exp .)
    LOCAL           reduce using rule 36 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 36 (exp -> exp DIVIDE exp .)
    END             reduce using rule 36 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 36 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 36 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 36 (exp -> exp DIVIDE exp .)
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! MOD             [ reduce using rule 36 (exp -> exp DIVIDE exp .) ]
  ! CONCAT          [ reduce using rule 36 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 68

    (37) exp -> exp MOD exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 37 (exp -> exp MOD exp .)
    PLUS            reduce using rule 37 (exp -> exp MOD exp .)
    MINUS           reduce using rule 37 (exp -> exp MOD exp .)
    TIMES           reduce using rule 37 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 37 (exp -> exp MOD exp .)
    MOD             reduce using rule 37 (exp -> exp MOD exp .)
    AND             reduce using rule 37 (exp -> exp MOD exp .)
    OR              reduce using rule 37 (exp -> exp MOD exp .)
    LESS            reduce using rule 37 (exp -> exp MOD exp .)
    LESSEQUAL       reduce using rule 37 (exp -> exp MOD exp .)
    GREATER         reduce using rule 37 (exp -> exp MOD exp .)
    GREATEREQUAL    reduce using rule 37 (exp -> exp MOD exp .)
    EQUAL           reduce using rule 37 (exp -> exp MOD exp .)
    NOTEQUAL        reduce using rule 37 (exp -> exp MOD exp .)
    CONCAT          reduce using rule 37 (exp -> exp MOD exp .)
    THEN            reduce using rule 37 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 37 (exp -> exp MOD exp .)
    ID              reduce using rule 37 (exp -> exp MOD exp .)
    WHILE           reduce using rule 37 (exp -> exp MOD exp .)
    IF              reduce using rule 37 (exp -> exp MOD exp .)
    RETURN          reduce using rule 37 (exp -> exp MOD exp .)
    VAR             reduce using rule 37 (exp -> exp MOD exp .)
    LOCAL           reduce using rule 37 (exp -> exp MOD exp .)
    $end            reduce using rule 37 (exp -> exp MOD exp .)
    END             reduce using rule 37 (exp -> exp MOD exp .)
    ELSE            reduce using rule 37 (exp -> exp MOD exp .)
    COMMA           reduce using rule 37 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 37 (exp -> exp MOD exp .)

  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! MOD             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]
  ! CONCAT          [ shift and go to state 52 ]


state 69

    (38) exp -> exp AND exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 38 (exp -> exp AND exp .)
    AND             reduce using rule 38 (exp -> exp AND exp .)
    OR              reduce using rule 38 (exp -> exp AND exp .)
    THEN            reduce using rule 38 (exp -> exp AND exp .)
    SEMICOLON       reduce using rule 38 (exp -> exp AND exp .)
    ID              reduce using rule 38 (exp -> exp AND exp .)
    WHILE           reduce using rule 38 (exp -> exp AND exp .)
    IF              reduce using rule 38 (exp -> exp AND exp .)
    RETURN          reduce using rule 38 (exp -> exp AND exp .)
    VAR             reduce using rule 38 (exp -> exp AND exp .)
    LOCAL           reduce using rule 38 (exp -> exp AND exp .)
    $end            reduce using rule 38 (exp -> exp AND exp .)
    END             reduce using rule 38 (exp -> exp AND exp .)
    ELSE            reduce using rule 38 (exp -> exp AND exp .)
    COMMA           reduce using rule 38 (exp -> exp AND exp .)
    RPAREN          reduce using rule 38 (exp -> exp AND exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! LESSEQUAL       [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! GREATEREQUAL    [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! EQUAL           [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! NOTEQUAL        [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! CONCAT          [ reduce using rule 38 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 70

    (39) exp -> exp OR exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 39 (exp -> exp OR exp .)
    AND             reduce using rule 39 (exp -> exp OR exp .)
    OR              reduce using rule 39 (exp -> exp OR exp .)
    THEN            reduce using rule 39 (exp -> exp OR exp .)
    SEMICOLON       reduce using rule 39 (exp -> exp OR exp .)
    ID              reduce using rule 39 (exp -> exp OR exp .)
    WHILE           reduce using rule 39 (exp -> exp OR exp .)
    IF              reduce using rule 39 (exp -> exp OR exp .)
    RETURN          reduce using rule 39 (exp -> exp OR exp .)
    VAR             reduce using rule 39 (exp -> exp OR exp .)
    LOCAL           reduce using rule 39 (exp -> exp OR exp .)
    $end            reduce using rule 39 (exp -> exp OR exp .)
    END             reduce using rule 39 (exp -> exp OR exp .)
    ELSE            reduce using rule 39 (exp -> exp OR exp .)
    COMMA           reduce using rule 39 (exp -> exp OR exp .)
    RPAREN          reduce using rule 39 (exp -> exp OR exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! LESSEQUAL       [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! GREATEREQUAL    [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! EQUAL           [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! NOTEQUAL        [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! CONCAT          [ reduce using rule 39 (exp -> exp OR exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 71

    (40) exp -> exp LESS exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 40 (exp -> exp LESS exp .)
    AND             reduce using rule 40 (exp -> exp LESS exp .)
    OR              reduce using rule 40 (exp -> exp LESS exp .)
    LESS            reduce using rule 40 (exp -> exp LESS exp .)
    LESSEQUAL       reduce using rule 40 (exp -> exp LESS exp .)
    GREATER         reduce using rule 40 (exp -> exp LESS exp .)
    GREATEREQUAL    reduce using rule 40 (exp -> exp LESS exp .)
    EQUAL           reduce using rule 40 (exp -> exp LESS exp .)
    NOTEQUAL        reduce using rule 40 (exp -> exp LESS exp .)
    THEN            reduce using rule 40 (exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp LESS exp .)
    ID              reduce using rule 40 (exp -> exp LESS exp .)
    WHILE           reduce using rule 40 (exp -> exp LESS exp .)
    IF              reduce using rule 40 (exp -> exp LESS exp .)
    RETURN          reduce using rule 40 (exp -> exp LESS exp .)
    VAR             reduce using rule 40 (exp -> exp LESS exp .)
    LOCAL           reduce using rule 40 (exp -> exp LESS exp .)
    $end            reduce using rule 40 (exp -> exp LESS exp .)
    END             reduce using rule 40 (exp -> exp LESS exp .)
    ELSE            reduce using rule 40 (exp -> exp LESS exp .)
    COMMA           reduce using rule 40 (exp -> exp LESS exp .)
    RPAREN          reduce using rule 40 (exp -> exp LESS exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! CONCAT          [ reduce using rule 40 (exp -> exp LESS exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 72

    (41) exp -> exp LESSEQUAL exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    AND             reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    OR              reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    LESS            reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    LESSEQUAL       reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    GREATER         reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    GREATEREQUAL    reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    EQUAL           reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    NOTEQUAL        reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    THEN            reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    SEMICOLON       reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    ID              reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    WHILE           reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    IF              reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    RETURN          reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    VAR             reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    LOCAL           reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    $end            reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    END             reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    ELSE            reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    COMMA           reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    RPAREN          reduce using rule 41 (exp -> exp LESSEQUAL exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! MINUS           [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! TIMES           [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! MOD             [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! CONCAT          [ reduce using rule 41 (exp -> exp LESSEQUAL exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 73

    (42) exp -> exp GREATER exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 42 (exp -> exp GREATER exp .)
    AND             reduce using rule 42 (exp -> exp GREATER exp .)
    OR              reduce using rule 42 (exp -> exp GREATER exp .)
    LESS            reduce using rule 42 (exp -> exp GREATER exp .)
    LESSEQUAL       reduce using rule 42 (exp -> exp GREATER exp .)
    GREATER         reduce using rule 42 (exp -> exp GREATER exp .)
    GREATEREQUAL    reduce using rule 42 (exp -> exp GREATER exp .)
    EQUAL           reduce using rule 42 (exp -> exp GREATER exp .)
    NOTEQUAL        reduce using rule 42 (exp -> exp GREATER exp .)
    THEN            reduce using rule 42 (exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp GREATER exp .)
    ID              reduce using rule 42 (exp -> exp GREATER exp .)
    WHILE           reduce using rule 42 (exp -> exp GREATER exp .)
    IF              reduce using rule 42 (exp -> exp GREATER exp .)
    RETURN          reduce using rule 42 (exp -> exp GREATER exp .)
    VAR             reduce using rule 42 (exp -> exp GREATER exp .)
    LOCAL           reduce using rule 42 (exp -> exp GREATER exp .)
    $end            reduce using rule 42 (exp -> exp GREATER exp .)
    END             reduce using rule 42 (exp -> exp GREATER exp .)
    ELSE            reduce using rule 42 (exp -> exp GREATER exp .)
    COMMA           reduce using rule 42 (exp -> exp GREATER exp .)
    RPAREN          reduce using rule 42 (exp -> exp GREATER exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! CONCAT          [ reduce using rule 42 (exp -> exp GREATER exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 74

    (43) exp -> exp GREATEREQUAL exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    AND             reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    OR              reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    LESS            reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    LESSEQUAL       reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    GREATER         reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    GREATEREQUAL    reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    EQUAL           reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    NOTEQUAL        reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    THEN            reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    ID              reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    WHILE           reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    IF              reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    RETURN          reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    VAR             reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    LOCAL           reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    $end            reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    END             reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    ELSE            reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    COMMA           reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    RPAREN          reduce using rule 43 (exp -> exp GREATEREQUAL exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! TIMES           [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! CONCAT          [ reduce using rule 43 (exp -> exp GREATEREQUAL exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 75

    (44) exp -> exp EQUAL exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 44 (exp -> exp EQUAL exp .)
    AND             reduce using rule 44 (exp -> exp EQUAL exp .)
    OR              reduce using rule 44 (exp -> exp EQUAL exp .)
    EQUAL           reduce using rule 44 (exp -> exp EQUAL exp .)
    NOTEQUAL        reduce using rule 44 (exp -> exp EQUAL exp .)
    THEN            reduce using rule 44 (exp -> exp EQUAL exp .)
    SEMICOLON       reduce using rule 44 (exp -> exp EQUAL exp .)
    ID              reduce using rule 44 (exp -> exp EQUAL exp .)
    WHILE           reduce using rule 44 (exp -> exp EQUAL exp .)
    IF              reduce using rule 44 (exp -> exp EQUAL exp .)
    RETURN          reduce using rule 44 (exp -> exp EQUAL exp .)
    VAR             reduce using rule 44 (exp -> exp EQUAL exp .)
    LOCAL           reduce using rule 44 (exp -> exp EQUAL exp .)
    $end            reduce using rule 44 (exp -> exp EQUAL exp .)
    END             reduce using rule 44 (exp -> exp EQUAL exp .)
    ELSE            reduce using rule 44 (exp -> exp EQUAL exp .)
    COMMA           reduce using rule 44 (exp -> exp EQUAL exp .)
    RPAREN          reduce using rule 44 (exp -> exp EQUAL exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! TIMES           [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! LESS            [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! GREATER         [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! GREATEREQUAL    [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! CONCAT          [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 76

    (45) exp -> exp NOTEQUAL exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    AND             reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    OR              reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    EQUAL           reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    NOTEQUAL        reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    THEN            reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    ID              reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    WHILE           reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    IF              reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    RETURN          reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    VAR             reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    LOCAL           reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    $end            reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    END             reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    ELSE            reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    COMMA           reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    RPAREN          reduce using rule 45 (exp -> exp NOTEQUAL exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    CONCAT          shift and go to state 52

  ! PLUS            [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! TIMES           [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! LESS            [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! GREATER         [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! GREATEREQUAL    [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! CONCAT          [ reduce using rule 45 (exp -> exp NOTEQUAL exp .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]


state 77

    (46) exp -> exp CONCAT exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    DO              reduce using rule 46 (exp -> exp CONCAT exp .)
    PLUS            reduce using rule 46 (exp -> exp CONCAT exp .)
    MINUS           reduce using rule 46 (exp -> exp CONCAT exp .)
    TIMES           reduce using rule 46 (exp -> exp CONCAT exp .)
    DIVIDE          reduce using rule 46 (exp -> exp CONCAT exp .)
    MOD             reduce using rule 46 (exp -> exp CONCAT exp .)
    AND             reduce using rule 46 (exp -> exp CONCAT exp .)
    OR              reduce using rule 46 (exp -> exp CONCAT exp .)
    LESS            reduce using rule 46 (exp -> exp CONCAT exp .)
    LESSEQUAL       reduce using rule 46 (exp -> exp CONCAT exp .)
    GREATER         reduce using rule 46 (exp -> exp CONCAT exp .)
    GREATEREQUAL    reduce using rule 46 (exp -> exp CONCAT exp .)
    EQUAL           reduce using rule 46 (exp -> exp CONCAT exp .)
    NOTEQUAL        reduce using rule 46 (exp -> exp CONCAT exp .)
    CONCAT          reduce using rule 46 (exp -> exp CONCAT exp .)
    THEN            reduce using rule 46 (exp -> exp CONCAT exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp CONCAT exp .)
    ID              reduce using rule 46 (exp -> exp CONCAT exp .)
    WHILE           reduce using rule 46 (exp -> exp CONCAT exp .)
    IF              reduce using rule 46 (exp -> exp CONCAT exp .)
    RETURN          reduce using rule 46 (exp -> exp CONCAT exp .)
    VAR             reduce using rule 46 (exp -> exp CONCAT exp .)
    LOCAL           reduce using rule 46 (exp -> exp CONCAT exp .)
    $end            reduce using rule 46 (exp -> exp CONCAT exp .)
    END             reduce using rule 46 (exp -> exp CONCAT exp .)
    ELSE            reduce using rule 46 (exp -> exp CONCAT exp .)
    COMMA           reduce using rule 46 (exp -> exp CONCAT exp .)
    RPAREN          reduce using rule 46 (exp -> exp CONCAT exp .)

  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 41 ]
  ! DIVIDE          [ shift and go to state 42 ]
  ! MOD             [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESSEQUAL       [ shift and go to state 47 ]
  ! GREATER         [ shift and go to state 48 ]
  ! GREATEREQUAL    [ shift and go to state 49 ]
  ! EQUAL           [ shift and go to state 50 ]
  ! NOTEQUAL        [ shift and go to state 51 ]
  ! CONCAT          [ shift and go to state 52 ]


state 78

    (14) command -> IF exp THEN block . elsestnt END
    (49) elsestnt -> . empty
    (50) elsestnt -> . ELSE block
    (1) empty -> .

    ELSE            shift and go to state 85
    END             reduce using rule 1 (empty -> .)

    elsestnt                       shift and go to state 83
    empty                          shift and go to state 84

state 79

    (19) expassign -> ASSIGN exp .
    (33) exp -> exp . PLUS exp
    (34) exp -> exp . MINUS exp
    (35) exp -> exp . TIMES exp
    (36) exp -> exp . DIVIDE exp
    (37) exp -> exp . MOD exp
    (38) exp -> exp . AND exp
    (39) exp -> exp . OR exp
    (40) exp -> exp . LESS exp
    (41) exp -> exp . LESSEQUAL exp
    (42) exp -> exp . GREATER exp
    (43) exp -> exp . GREATEREQUAL exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NOTEQUAL exp
    (46) exp -> exp . CONCAT exp

    SEMICOLON       reduce using rule 19 (expassign -> ASSIGN exp .)
    ID              reduce using rule 19 (expassign -> ASSIGN exp .)
    WHILE           reduce using rule 19 (expassign -> ASSIGN exp .)
    IF              reduce using rule 19 (expassign -> ASSIGN exp .)
    RETURN          reduce using rule 19 (expassign -> ASSIGN exp .)
    VAR             reduce using rule 19 (expassign -> ASSIGN exp .)
    LOCAL           reduce using rule 19 (expassign -> ASSIGN exp .)
    $end            reduce using rule 19 (expassign -> ASSIGN exp .)
    END             reduce using rule 19 (expassign -> ASSIGN exp .)
    ELSE            reduce using rule 19 (expassign -> ASSIGN exp .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45
    LESS            shift and go to state 46
    LESSEQUAL       shift and go to state 47
    GREATER         shift and go to state 48
    GREATEREQUAL    shift and go to state 49
    EQUAL           shift and go to state 50
    NOTEQUAL        shift and go to state 51
    CONCAT          shift and go to state 52


state 80

    (20) functiondeclaration -> LOCAL FUNCTION ID LPAREN . paramlist RPAREN block END
    (22) paramlist -> . empty
    (23) paramlist -> . paramseq
    (1) empty -> .
    (24) paramseq -> . ID
    (25) paramseq -> . ID COMMA paramseq

    RPAREN          reduce using rule 1 (empty -> .)
    ID              shift and go to state 86

    paramlist                      shift and go to state 87
    empty                          shift and go to state 88
    paramseq                       shift and go to state 89

state 81

    (28) explist -> exp COMMA explist .

    RPAREN          reduce using rule 28 (explist -> exp COMMA explist .)


state 82

    (13) command -> WHILE exp DO block END .

    SEMICOLON       reduce using rule 13 (command -> WHILE exp DO block END .)
    ID              reduce using rule 13 (command -> WHILE exp DO block END .)
    WHILE           reduce using rule 13 (command -> WHILE exp DO block END .)
    IF              reduce using rule 13 (command -> WHILE exp DO block END .)
    RETURN          reduce using rule 13 (command -> WHILE exp DO block END .)
    VAR             reduce using rule 13 (command -> WHILE exp DO block END .)
    LOCAL           reduce using rule 13 (command -> WHILE exp DO block END .)
    $end            reduce using rule 13 (command -> WHILE exp DO block END .)
    END             reduce using rule 13 (command -> WHILE exp DO block END .)
    ELSE            reduce using rule 13 (command -> WHILE exp DO block END .)


state 83

    (14) command -> IF exp THEN block elsestnt . END

    END             shift and go to state 90


state 84

    (49) elsestnt -> empty .

    END             reduce using rule 49 (elsestnt -> empty .)


state 85

    (50) elsestnt -> ELSE . block
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    block                          shift and go to state 91
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 86

    (24) paramseq -> ID .
    (25) paramseq -> ID . COMMA paramseq

    RPAREN          reduce using rule 24 (paramseq -> ID .)
    COMMA           shift and go to state 92


state 87

    (20) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist . RPAREN block END

    RPAREN          shift and go to state 93


state 88

    (22) paramlist -> empty .

    RPAREN          reduce using rule 22 (paramlist -> empty .)


state 89

    (23) paramlist -> paramseq .

    RPAREN          reduce using rule 23 (paramlist -> paramseq .)


state 90

    (14) command -> IF exp THEN block elsestnt END .

    SEMICOLON       reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    ID              reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    WHILE           reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    IF              reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    RETURN          reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    VAR             reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    LOCAL           reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    $end            reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    END             reduce using rule 14 (command -> IF exp THEN block elsestnt END .)
    ELSE            reduce using rule 14 (command -> IF exp THEN block elsestnt END .)


state 91

    (50) elsestnt -> ELSE block .

    END             reduce using rule 50 (elsestnt -> ELSE block .)


state 92

    (25) paramseq -> ID COMMA . paramseq
    (24) paramseq -> . ID
    (25) paramseq -> . ID COMMA paramseq

    ID              shift and go to state 86

    paramseq                       shift and go to state 94

state 93

    (20) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN . block END
    (3) block -> . blocklist
    (4) blocklist -> . command blockterminator blocklist
    (5) blocklist -> . empty
    (8) command -> . ID ASSIGN exp
    (9) command -> . functioncall
    (10) command -> . vardeclaration
    (11) command -> . localdeclaration
    (12) command -> . functiondeclaration
    (13) command -> . WHILE exp DO block END
    (14) command -> . IF exp THEN block elsestnt END
    (15) command -> . RETURN exp
    (1) empty -> .
    (21) functioncall -> . ID LPAREN explist RPAREN
    (17) vardeclaration -> . VAR ID expassign
    (16) localdeclaration -> . LOCAL ID expassign
    (20) functiondeclaration -> . LOCAL FUNCTION ID LPAREN paramlist RPAREN block END

    ID              shift and go to state 6
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    RETURN          shift and go to state 13
    END             reduce using rule 1 (empty -> .)
    VAR             shift and go to state 14
    LOCAL           shift and go to state 15

    block                          shift and go to state 95
    blocklist                      shift and go to state 3
    command                        shift and go to state 4
    empty                          shift and go to state 5
    functioncall                   shift and go to state 7
    vardeclaration                 shift and go to state 8
    localdeclaration               shift and go to state 9
    functiondeclaration            shift and go to state 10

state 94

    (25) paramseq -> ID COMMA paramseq .

    RPAREN          reduce using rule 25 (paramseq -> ID COMMA paramseq .)


state 95

    (20) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block . END

    END             shift and go to state 96


state 96

    (20) functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .

    SEMICOLON       reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    ID              reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    WHILE           reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    IF              reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    RETURN          reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    VAR             reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    LOCAL           reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    $end            reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    END             reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)
    ELSE            reduce using rule 20 (functiondeclaration -> LOCAL FUNCTION ID LPAREN paramlist RPAREN block END .)

