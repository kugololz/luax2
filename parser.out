Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    PRINT

Grammar

Rule 0     S' -> chunk
Rule 1     chunk -> statlist
Rule 2     chunk -> statlist laststat
Rule 3     statlist -> statlist stat SEMI
Rule 4     statlist -> statlist stat
Rule 5     statlist -> empty
Rule 6     stat -> varlist ASSIGN explist
Rule 7     stat -> functioncall
Rule 8     stat -> DO block END
Rule 9     stat -> WHILE exp DO block END
Rule 10    stat -> REPEAT block UNTIL exp
Rule 11    stat -> IF exp THEN block elseiflist opt_else END
Rule 12    stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END
Rule 13    stat -> FOR namelist IN explist DO block END
Rule 14    stat -> FUNCTION funcname funcbody
Rule 15    stat -> LOCAL FUNCTION NAME funcbody
Rule 16    stat -> LOCAL namelist opt_assign
Rule 17    laststat -> RETURN opt_explist
Rule 18    laststat -> BREAK
Rule 19    funcname -> NAME nameparts opt_colon_name
Rule 20    varlist -> var varlist_tail
Rule 21    varlist_tail -> COMMA var varlist_tail
Rule 22    varlist_tail -> empty
Rule 23    var -> NAME
Rule 24    var -> prefixexp LBRACK exp RBRACK
Rule 25    var -> prefixexp DOT NAME
Rule 26    functioncall -> NAME LPAREN opt_explist RPAREN
Rule 27    functioncall -> prefixexp COLON NAME args
Rule 28    args -> LPAREN opt_explist RPAREN
Rule 29    args -> tableconstructor
Rule 30    args -> STRING
Rule 31    namelist -> NAME namelist_tail
Rule 32    namelist_tail -> COMMA NAME namelist_tail
Rule 33    namelist_tail -> empty
Rule 34    explist -> exp exp_tail
Rule 35    exp_tail -> COMMA exp exp_tail
Rule 36    exp_tail -> empty
Rule 37    exp -> NIL
Rule 38    exp -> FALSE
Rule 39    exp -> TRUE
Rule 40    exp -> NUMBER
Rule 41    exp -> STRING
Rule 42    exp -> ELLIPSIS
Rule 43    exp -> function
Rule 44    exp -> prefixexp
Rule 45    exp -> tableconstructor
Rule 46    exp -> exp binop exp
Rule 47    exp -> unop exp
Rule 48    prefixexp -> var
Rule 49    prefixexp -> functioncall
Rule 50    prefixexp -> LPAREN exp RPAREN
Rule 51    function -> FUNCTION funcbody
Rule 52    funcbody -> LPAREN opt_parlist RPAREN block END
Rule 53    parlist -> namelist opt_comma_ellipsis
Rule 54    parlist -> ELLIPSIS
Rule 55    tableconstructor -> LBRACE opt_fieldlist RBRACE
Rule 56    fieldlist -> field field_tail
Rule 57    field_tail -> fieldsep field field_tail
Rule 58    field_tail -> empty
Rule 59    field -> LBRACK exp RBRACK ASSIGN exp
Rule 60    field -> NAME ASSIGN exp
Rule 61    field -> exp
Rule 62    fieldsep -> COMMA
Rule 63    fieldsep -> SEMI
Rule 64    binop -> PLUS
Rule 65    binop -> MINUS
Rule 66    binop -> TIMES
Rule 67    binop -> DIVIDE
Rule 68    binop -> POWER
Rule 69    binop -> MOD
Rule 70    binop -> CONCAT
Rule 71    binop -> LT
Rule 72    binop -> LE
Rule 73    binop -> GT
Rule 74    binop -> GE
Rule 75    binop -> EQ
Rule 76    binop -> NE
Rule 77    binop -> AND
Rule 78    binop -> OR
Rule 79    unop -> MINUS
Rule 80    unop -> NOT
Rule 81    unop -> LEN
Rule 82    opt_explist -> explist
Rule 83    opt_explist -> empty
Rule 84    opt_comma_exp -> COMMA exp
Rule 85    opt_comma_exp -> empty
Rule 86    opt_assign -> ASSIGN explist
Rule 87    opt_assign -> empty
Rule 88    opt_fieldlist -> fieldlist
Rule 89    opt_fieldlist -> empty
Rule 90    opt_parlist -> parlist
Rule 91    opt_parlist -> empty
Rule 92    opt_else -> ELSE block
Rule 93    opt_else -> empty
Rule 94    opt_comma_ellipsis -> COMMA ELLIPSIS
Rule 95    opt_comma_ellipsis -> empty
Rule 96    elseiflist -> elseiflist ELSEIF exp THEN block
Rule 97    elseiflist -> empty
Rule 98    nameparts -> DOT NAME nameparts
Rule 99    nameparts -> empty
Rule 100   opt_colon_name -> COLON NAME
Rule 101   opt_colon_name -> empty
Rule 102   block -> chunk
Rule 103   empty -> <empty>

Terminals, with rules where they appear

AND                  : 77
ASSIGN               : 6 12 59 60 86
BREAK                : 18
COLON                : 27 100
COMMA                : 12 21 32 35 62 84 94
CONCAT               : 70
DIVIDE               : 67
DO                   : 8 9 12 13
DOT                  : 25 98
ELLIPSIS             : 42 54 94
ELSE                 : 92
ELSEIF               : 96
END                  : 8 9 11 12 13 52
EQ                   : 75
FALSE                : 38
FOR                  : 12 13
FUNCTION             : 14 15 51
GE                   : 74
GT                   : 73
IF                   : 11
IN                   : 13
LBRACE               : 55
LBRACK               : 24 59
LE                   : 72
LEN                  : 81
LOCAL                : 15 16
LPAREN               : 26 28 50 52
LT                   : 71
MINUS                : 65 79
MOD                  : 69
NAME                 : 12 15 19 23 25 26 27 31 32 60 98 100
NE                   : 76
NIL                  : 37
NOT                  : 80
NUMBER               : 40
OR                   : 78
PLUS                 : 64
POWER                : 68
PRINT                : 
RBRACE               : 55
RBRACK               : 24 59
REPEAT               : 10
RETURN               : 17
RPAREN               : 26 28 50 52
SEMI                 : 3 63
STRING               : 30 41
THEN                 : 11 96
TIMES                : 66
TRUE                 : 39
UNTIL                : 10
WHILE                : 9
error                : 

Nonterminals, with rules where they appear

args                 : 27
binop                : 46
block                : 8 9 10 11 12 13 52 92 96
chunk                : 102 0
elseiflist           : 11 96
empty                : 5 22 33 36 58 83 85 87 89 91 93 95 97 99 101
exp                  : 9 10 11 12 12 24 34 35 46 46 47 50 59 59 60 61 84 96
exp_tail             : 34 35
explist              : 6 13 82 86
field                : 56 57
field_tail           : 56 57
fieldlist            : 88
fieldsep             : 57
funcbody             : 14 15 51
funcname             : 14
function             : 43
functioncall         : 7 49
laststat             : 2
namelist             : 13 16 53
namelist_tail        : 31 32
nameparts            : 19 98
opt_assign           : 16
opt_colon_name       : 19
opt_comma_ellipsis   : 53
opt_comma_exp        : 12
opt_else             : 11
opt_explist          : 17 26 28
opt_fieldlist        : 55
opt_parlist          : 52
parlist              : 90
prefixexp            : 24 25 27 44
stat                 : 3 4
statlist             : 1 2 3 4
tableconstructor     : 29 45
unop                 : 47
var                  : 20 21 48
varlist              : 6
varlist_tail         : 20 21

Parsing method: LALR

state 0

    (0) S' -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    $end            reduce using rule 103 (empty -> .)

    chunk                          shift and go to state 1
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> chunk .



state 2

    (1) chunk -> statlist .
    (2) chunk -> statlist . laststat
    (3) statlist -> statlist . stat SEMI
    (4) statlist -> statlist . stat
    (17) laststat -> . RETURN opt_explist
    (18) laststat -> . BREAK
    (6) stat -> . varlist ASSIGN explist
    (7) stat -> . functioncall
    (8) stat -> . DO block END
    (9) stat -> . WHILE exp DO block END
    (10) stat -> . REPEAT block UNTIL exp
    (11) stat -> . IF exp THEN block elseiflist opt_else END
    (12) stat -> . FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END
    (13) stat -> . FOR namelist IN explist DO block END
    (14) stat -> . FUNCTION funcname funcbody
    (15) stat -> . LOCAL FUNCTION NAME funcbody
    (16) stat -> . LOCAL namelist opt_assign
    (20) varlist -> . var varlist_tail
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN

    $end            reduce using rule 1 (chunk -> statlist .)
    END             reduce using rule 1 (chunk -> statlist .)
    UNTIL           reduce using rule 1 (chunk -> statlist .)
    ELSEIF          reduce using rule 1 (chunk -> statlist .)
    ELSE            reduce using rule 1 (chunk -> statlist .)
    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    FUNCTION        shift and go to state 16
    LOCAL           shift and go to state 17
    NAME            shift and go to state 15
    LPAREN          shift and go to state 19

    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    functioncall                   shift and go to state 9
    var                            shift and go to state 18
    prefixexp                      shift and go to state 20

state 3

    (5) statlist -> empty .

    RETURN          reduce using rule 5 (statlist -> empty .)
    BREAK           reduce using rule 5 (statlist -> empty .)
    DO              reduce using rule 5 (statlist -> empty .)
    WHILE           reduce using rule 5 (statlist -> empty .)
    REPEAT          reduce using rule 5 (statlist -> empty .)
    IF              reduce using rule 5 (statlist -> empty .)
    FOR             reduce using rule 5 (statlist -> empty .)
    FUNCTION        reduce using rule 5 (statlist -> empty .)
    LOCAL           reduce using rule 5 (statlist -> empty .)
    NAME            reduce using rule 5 (statlist -> empty .)
    LPAREN          reduce using rule 5 (statlist -> empty .)
    $end            reduce using rule 5 (statlist -> empty .)
    END             reduce using rule 5 (statlist -> empty .)
    UNTIL           reduce using rule 5 (statlist -> empty .)
    ELSEIF          reduce using rule 5 (statlist -> empty .)
    ELSE            reduce using rule 5 (statlist -> empty .)


state 4

    (2) chunk -> statlist laststat .

    $end            reduce using rule 2 (chunk -> statlist laststat .)
    END             reduce using rule 2 (chunk -> statlist laststat .)
    UNTIL           reduce using rule 2 (chunk -> statlist laststat .)
    ELSEIF          reduce using rule 2 (chunk -> statlist laststat .)
    ELSE            reduce using rule 2 (chunk -> statlist laststat .)


state 5

    (3) statlist -> statlist stat . SEMI
    (4) statlist -> statlist stat .

    SEMI            shift and go to state 21
    RETURN          reduce using rule 4 (statlist -> statlist stat .)
    BREAK           reduce using rule 4 (statlist -> statlist stat .)
    DO              reduce using rule 4 (statlist -> statlist stat .)
    WHILE           reduce using rule 4 (statlist -> statlist stat .)
    REPEAT          reduce using rule 4 (statlist -> statlist stat .)
    IF              reduce using rule 4 (statlist -> statlist stat .)
    FOR             reduce using rule 4 (statlist -> statlist stat .)
    FUNCTION        reduce using rule 4 (statlist -> statlist stat .)
    LOCAL           reduce using rule 4 (statlist -> statlist stat .)
    NAME            reduce using rule 4 (statlist -> statlist stat .)
    LPAREN          reduce using rule 4 (statlist -> statlist stat .)
    $end            reduce using rule 4 (statlist -> statlist stat .)
    END             reduce using rule 4 (statlist -> statlist stat .)
    UNTIL           reduce using rule 4 (statlist -> statlist stat .)
    ELSEIF          reduce using rule 4 (statlist -> statlist stat .)
    ELSE            reduce using rule 4 (statlist -> statlist stat .)


state 6

    (17) laststat -> RETURN . opt_explist
    (82) opt_explist -> . explist
    (83) opt_explist -> . empty
    (34) explist -> . exp exp_tail
    (103) empty -> .
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    opt_explist                    shift and go to state 22
    explist                        shift and go to state 23
    empty                          shift and go to state 24
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 7

    (18) laststat -> BREAK .

    $end            reduce using rule 18 (laststat -> BREAK .)
    END             reduce using rule 18 (laststat -> BREAK .)
    UNTIL           reduce using rule 18 (laststat -> BREAK .)
    ELSEIF          reduce using rule 18 (laststat -> BREAK .)
    ELSE            reduce using rule 18 (laststat -> BREAK .)


state 8

    (6) stat -> varlist . ASSIGN explist

    ASSIGN          shift and go to state 44


state 9

    (7) stat -> functioncall .
    (49) prefixexp -> functioncall .

    SEMI            reduce using rule 7 (stat -> functioncall .)
    RETURN          reduce using rule 7 (stat -> functioncall .)
    BREAK           reduce using rule 7 (stat -> functioncall .)
    DO              reduce using rule 7 (stat -> functioncall .)
    WHILE           reduce using rule 7 (stat -> functioncall .)
    REPEAT          reduce using rule 7 (stat -> functioncall .)
    IF              reduce using rule 7 (stat -> functioncall .)
    FOR             reduce using rule 7 (stat -> functioncall .)
    FUNCTION        reduce using rule 7 (stat -> functioncall .)
    LOCAL           reduce using rule 7 (stat -> functioncall .)
    NAME            reduce using rule 7 (stat -> functioncall .)
    LPAREN          reduce using rule 7 (stat -> functioncall .)
    $end            reduce using rule 7 (stat -> functioncall .)
    END             reduce using rule 7 (stat -> functioncall .)
    UNTIL           reduce using rule 7 (stat -> functioncall .)
    ELSEIF          reduce using rule 7 (stat -> functioncall .)
    ELSE            reduce using rule 7 (stat -> functioncall .)
    COLON           reduce using rule 49 (prefixexp -> functioncall .)
    LBRACK          reduce using rule 49 (prefixexp -> functioncall .)
    DOT             reduce using rule 49 (prefixexp -> functioncall .)


state 10

    (8) stat -> DO . block END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 45
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 11

    (9) stat -> WHILE . exp DO block END
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 47
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 12

    (10) stat -> REPEAT . block UNTIL exp
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)

    block                          shift and go to state 48
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 13

    (11) stat -> IF . exp THEN block elseiflist opt_else END
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 49
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 14

    (12) stat -> FOR . NAME ASSIGN exp COMMA exp opt_comma_exp DO block END
    (13) stat -> FOR . namelist IN explist DO block END
    (31) namelist -> . NAME namelist_tail

    NAME            shift and go to state 50

    namelist                       shift and go to state 51

state 15

    (26) functioncall -> NAME . LPAREN opt_explist RPAREN
    (23) var -> NAME .

    LPAREN          shift and go to state 52
    COMMA           reduce using rule 23 (var -> NAME .)
    ASSIGN          reduce using rule 23 (var -> NAME .)
    COLON           reduce using rule 23 (var -> NAME .)
    LBRACK          reduce using rule 23 (var -> NAME .)
    DOT             reduce using rule 23 (var -> NAME .)


state 16

    (14) stat -> FUNCTION . funcname funcbody
    (19) funcname -> . NAME nameparts opt_colon_name

    NAME            shift and go to state 54

    funcname                       shift and go to state 53

state 17

    (15) stat -> LOCAL . FUNCTION NAME funcbody
    (16) stat -> LOCAL . namelist opt_assign
    (31) namelist -> . NAME namelist_tail

    FUNCTION        shift and go to state 55
    NAME            shift and go to state 56

    namelist                       shift and go to state 57

state 18

    (20) varlist -> var . varlist_tail
    (48) prefixexp -> var .
    (21) varlist_tail -> . COMMA var varlist_tail
    (22) varlist_tail -> . empty
    (103) empty -> .

    COLON           reduce using rule 48 (prefixexp -> var .)
    LBRACK          reduce using rule 48 (prefixexp -> var .)
    DOT             reduce using rule 48 (prefixexp -> var .)
    COMMA           shift and go to state 59
    ASSIGN          reduce using rule 103 (empty -> .)

    varlist_tail                   shift and go to state 58
    empty                          shift and go to state 60

state 19

    (50) prefixexp -> LPAREN . exp RPAREN
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 61
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 20

    (27) functioncall -> prefixexp . COLON NAME args
    (24) var -> prefixexp . LBRACK exp RBRACK
    (25) var -> prefixexp . DOT NAME

    COLON           shift and go to state 62
    LBRACK          shift and go to state 63
    DOT             shift and go to state 64


state 21

    (3) statlist -> statlist stat SEMI .

    RETURN          reduce using rule 3 (statlist -> statlist stat SEMI .)
    BREAK           reduce using rule 3 (statlist -> statlist stat SEMI .)
    DO              reduce using rule 3 (statlist -> statlist stat SEMI .)
    WHILE           reduce using rule 3 (statlist -> statlist stat SEMI .)
    REPEAT          reduce using rule 3 (statlist -> statlist stat SEMI .)
    IF              reduce using rule 3 (statlist -> statlist stat SEMI .)
    FOR             reduce using rule 3 (statlist -> statlist stat SEMI .)
    FUNCTION        reduce using rule 3 (statlist -> statlist stat SEMI .)
    LOCAL           reduce using rule 3 (statlist -> statlist stat SEMI .)
    NAME            reduce using rule 3 (statlist -> statlist stat SEMI .)
    LPAREN          reduce using rule 3 (statlist -> statlist stat SEMI .)
    $end            reduce using rule 3 (statlist -> statlist stat SEMI .)
    END             reduce using rule 3 (statlist -> statlist stat SEMI .)
    UNTIL           reduce using rule 3 (statlist -> statlist stat SEMI .)
    ELSEIF          reduce using rule 3 (statlist -> statlist stat SEMI .)
    ELSE            reduce using rule 3 (statlist -> statlist stat SEMI .)


state 22

    (17) laststat -> RETURN opt_explist .

    $end            reduce using rule 17 (laststat -> RETURN opt_explist .)
    END             reduce using rule 17 (laststat -> RETURN opt_explist .)
    UNTIL           reduce using rule 17 (laststat -> RETURN opt_explist .)
    ELSEIF          reduce using rule 17 (laststat -> RETURN opt_explist .)
    ELSE            reduce using rule 17 (laststat -> RETURN opt_explist .)


state 23

    (82) opt_explist -> explist .

    $end            reduce using rule 82 (opt_explist -> explist .)
    END             reduce using rule 82 (opt_explist -> explist .)
    UNTIL           reduce using rule 82 (opt_explist -> explist .)
    ELSEIF          reduce using rule 82 (opt_explist -> explist .)
    ELSE            reduce using rule 82 (opt_explist -> explist .)
    RPAREN          reduce using rule 82 (opt_explist -> explist .)


state 24

    (83) opt_explist -> empty .

    $end            reduce using rule 83 (opt_explist -> empty .)
    END             reduce using rule 83 (opt_explist -> empty .)
    UNTIL           reduce using rule 83 (opt_explist -> empty .)
    ELSEIF          reduce using rule 83 (opt_explist -> empty .)
    ELSE            reduce using rule 83 (opt_explist -> empty .)
    RPAREN          reduce using rule 83 (opt_explist -> empty .)


state 25

    (34) explist -> exp . exp_tail
    (46) exp -> exp . binop exp
    (35) exp_tail -> . COMMA exp exp_tail
    (36) exp_tail -> . empty
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR
    (103) empty -> .

    COMMA           shift and go to state 67
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    SEMI            reduce using rule 103 (empty -> .)
    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    RPAREN          reduce using rule 103 (empty -> .)

    exp_tail                       shift and go to state 65
    binop                          shift and go to state 66
    empty                          shift and go to state 68

state 26

    (37) exp -> NIL .

    COMMA           reduce using rule 37 (exp -> NIL .)
    PLUS            reduce using rule 37 (exp -> NIL .)
    MINUS           reduce using rule 37 (exp -> NIL .)
    TIMES           reduce using rule 37 (exp -> NIL .)
    DIVIDE          reduce using rule 37 (exp -> NIL .)
    POWER           reduce using rule 37 (exp -> NIL .)
    MOD             reduce using rule 37 (exp -> NIL .)
    CONCAT          reduce using rule 37 (exp -> NIL .)
    LT              reduce using rule 37 (exp -> NIL .)
    LE              reduce using rule 37 (exp -> NIL .)
    GT              reduce using rule 37 (exp -> NIL .)
    GE              reduce using rule 37 (exp -> NIL .)
    EQ              reduce using rule 37 (exp -> NIL .)
    NE              reduce using rule 37 (exp -> NIL .)
    AND             reduce using rule 37 (exp -> NIL .)
    OR              reduce using rule 37 (exp -> NIL .)
    $end            reduce using rule 37 (exp -> NIL .)
    END             reduce using rule 37 (exp -> NIL .)
    UNTIL           reduce using rule 37 (exp -> NIL .)
    ELSEIF          reduce using rule 37 (exp -> NIL .)
    ELSE            reduce using rule 37 (exp -> NIL .)
    DO              reduce using rule 37 (exp -> NIL .)
    THEN            reduce using rule 37 (exp -> NIL .)
    RPAREN          reduce using rule 37 (exp -> NIL .)
    SEMI            reduce using rule 37 (exp -> NIL .)
    RBRACE          reduce using rule 37 (exp -> NIL .)
    RETURN          reduce using rule 37 (exp -> NIL .)
    BREAK           reduce using rule 37 (exp -> NIL .)
    WHILE           reduce using rule 37 (exp -> NIL .)
    REPEAT          reduce using rule 37 (exp -> NIL .)
    IF              reduce using rule 37 (exp -> NIL .)
    FOR             reduce using rule 37 (exp -> NIL .)
    FUNCTION        reduce using rule 37 (exp -> NIL .)
    LOCAL           reduce using rule 37 (exp -> NIL .)
    NAME            reduce using rule 37 (exp -> NIL .)
    LPAREN          reduce using rule 37 (exp -> NIL .)
    RBRACK          reduce using rule 37 (exp -> NIL .)


state 27

    (38) exp -> FALSE .

    COMMA           reduce using rule 38 (exp -> FALSE .)
    PLUS            reduce using rule 38 (exp -> FALSE .)
    MINUS           reduce using rule 38 (exp -> FALSE .)
    TIMES           reduce using rule 38 (exp -> FALSE .)
    DIVIDE          reduce using rule 38 (exp -> FALSE .)
    POWER           reduce using rule 38 (exp -> FALSE .)
    MOD             reduce using rule 38 (exp -> FALSE .)
    CONCAT          reduce using rule 38 (exp -> FALSE .)
    LT              reduce using rule 38 (exp -> FALSE .)
    LE              reduce using rule 38 (exp -> FALSE .)
    GT              reduce using rule 38 (exp -> FALSE .)
    GE              reduce using rule 38 (exp -> FALSE .)
    EQ              reduce using rule 38 (exp -> FALSE .)
    NE              reduce using rule 38 (exp -> FALSE .)
    AND             reduce using rule 38 (exp -> FALSE .)
    OR              reduce using rule 38 (exp -> FALSE .)
    $end            reduce using rule 38 (exp -> FALSE .)
    END             reduce using rule 38 (exp -> FALSE .)
    UNTIL           reduce using rule 38 (exp -> FALSE .)
    ELSEIF          reduce using rule 38 (exp -> FALSE .)
    ELSE            reduce using rule 38 (exp -> FALSE .)
    DO              reduce using rule 38 (exp -> FALSE .)
    THEN            reduce using rule 38 (exp -> FALSE .)
    RPAREN          reduce using rule 38 (exp -> FALSE .)
    SEMI            reduce using rule 38 (exp -> FALSE .)
    RBRACE          reduce using rule 38 (exp -> FALSE .)
    RETURN          reduce using rule 38 (exp -> FALSE .)
    BREAK           reduce using rule 38 (exp -> FALSE .)
    WHILE           reduce using rule 38 (exp -> FALSE .)
    REPEAT          reduce using rule 38 (exp -> FALSE .)
    IF              reduce using rule 38 (exp -> FALSE .)
    FOR             reduce using rule 38 (exp -> FALSE .)
    FUNCTION        reduce using rule 38 (exp -> FALSE .)
    LOCAL           reduce using rule 38 (exp -> FALSE .)
    NAME            reduce using rule 38 (exp -> FALSE .)
    LPAREN          reduce using rule 38 (exp -> FALSE .)
    RBRACK          reduce using rule 38 (exp -> FALSE .)


state 28

    (39) exp -> TRUE .

    COMMA           reduce using rule 39 (exp -> TRUE .)
    PLUS            reduce using rule 39 (exp -> TRUE .)
    MINUS           reduce using rule 39 (exp -> TRUE .)
    TIMES           reduce using rule 39 (exp -> TRUE .)
    DIVIDE          reduce using rule 39 (exp -> TRUE .)
    POWER           reduce using rule 39 (exp -> TRUE .)
    MOD             reduce using rule 39 (exp -> TRUE .)
    CONCAT          reduce using rule 39 (exp -> TRUE .)
    LT              reduce using rule 39 (exp -> TRUE .)
    LE              reduce using rule 39 (exp -> TRUE .)
    GT              reduce using rule 39 (exp -> TRUE .)
    GE              reduce using rule 39 (exp -> TRUE .)
    EQ              reduce using rule 39 (exp -> TRUE .)
    NE              reduce using rule 39 (exp -> TRUE .)
    AND             reduce using rule 39 (exp -> TRUE .)
    OR              reduce using rule 39 (exp -> TRUE .)
    $end            reduce using rule 39 (exp -> TRUE .)
    END             reduce using rule 39 (exp -> TRUE .)
    UNTIL           reduce using rule 39 (exp -> TRUE .)
    ELSEIF          reduce using rule 39 (exp -> TRUE .)
    ELSE            reduce using rule 39 (exp -> TRUE .)
    DO              reduce using rule 39 (exp -> TRUE .)
    THEN            reduce using rule 39 (exp -> TRUE .)
    RPAREN          reduce using rule 39 (exp -> TRUE .)
    SEMI            reduce using rule 39 (exp -> TRUE .)
    RBRACE          reduce using rule 39 (exp -> TRUE .)
    RETURN          reduce using rule 39 (exp -> TRUE .)
    BREAK           reduce using rule 39 (exp -> TRUE .)
    WHILE           reduce using rule 39 (exp -> TRUE .)
    REPEAT          reduce using rule 39 (exp -> TRUE .)
    IF              reduce using rule 39 (exp -> TRUE .)
    FOR             reduce using rule 39 (exp -> TRUE .)
    FUNCTION        reduce using rule 39 (exp -> TRUE .)
    LOCAL           reduce using rule 39 (exp -> TRUE .)
    NAME            reduce using rule 39 (exp -> TRUE .)
    LPAREN          reduce using rule 39 (exp -> TRUE .)
    RBRACK          reduce using rule 39 (exp -> TRUE .)


state 29

    (40) exp -> NUMBER .

    COMMA           reduce using rule 40 (exp -> NUMBER .)
    PLUS            reduce using rule 40 (exp -> NUMBER .)
    MINUS           reduce using rule 40 (exp -> NUMBER .)
    TIMES           reduce using rule 40 (exp -> NUMBER .)
    DIVIDE          reduce using rule 40 (exp -> NUMBER .)
    POWER           reduce using rule 40 (exp -> NUMBER .)
    MOD             reduce using rule 40 (exp -> NUMBER .)
    CONCAT          reduce using rule 40 (exp -> NUMBER .)
    LT              reduce using rule 40 (exp -> NUMBER .)
    LE              reduce using rule 40 (exp -> NUMBER .)
    GT              reduce using rule 40 (exp -> NUMBER .)
    GE              reduce using rule 40 (exp -> NUMBER .)
    EQ              reduce using rule 40 (exp -> NUMBER .)
    NE              reduce using rule 40 (exp -> NUMBER .)
    AND             reduce using rule 40 (exp -> NUMBER .)
    OR              reduce using rule 40 (exp -> NUMBER .)
    $end            reduce using rule 40 (exp -> NUMBER .)
    END             reduce using rule 40 (exp -> NUMBER .)
    UNTIL           reduce using rule 40 (exp -> NUMBER .)
    ELSEIF          reduce using rule 40 (exp -> NUMBER .)
    ELSE            reduce using rule 40 (exp -> NUMBER .)
    DO              reduce using rule 40 (exp -> NUMBER .)
    THEN            reduce using rule 40 (exp -> NUMBER .)
    RPAREN          reduce using rule 40 (exp -> NUMBER .)
    SEMI            reduce using rule 40 (exp -> NUMBER .)
    RBRACE          reduce using rule 40 (exp -> NUMBER .)
    RETURN          reduce using rule 40 (exp -> NUMBER .)
    BREAK           reduce using rule 40 (exp -> NUMBER .)
    WHILE           reduce using rule 40 (exp -> NUMBER .)
    REPEAT          reduce using rule 40 (exp -> NUMBER .)
    IF              reduce using rule 40 (exp -> NUMBER .)
    FOR             reduce using rule 40 (exp -> NUMBER .)
    FUNCTION        reduce using rule 40 (exp -> NUMBER .)
    LOCAL           reduce using rule 40 (exp -> NUMBER .)
    NAME            reduce using rule 40 (exp -> NUMBER .)
    LPAREN          reduce using rule 40 (exp -> NUMBER .)
    RBRACK          reduce using rule 40 (exp -> NUMBER .)


state 30

    (41) exp -> STRING .

    COMMA           reduce using rule 41 (exp -> STRING .)
    PLUS            reduce using rule 41 (exp -> STRING .)
    MINUS           reduce using rule 41 (exp -> STRING .)
    TIMES           reduce using rule 41 (exp -> STRING .)
    DIVIDE          reduce using rule 41 (exp -> STRING .)
    POWER           reduce using rule 41 (exp -> STRING .)
    MOD             reduce using rule 41 (exp -> STRING .)
    CONCAT          reduce using rule 41 (exp -> STRING .)
    LT              reduce using rule 41 (exp -> STRING .)
    LE              reduce using rule 41 (exp -> STRING .)
    GT              reduce using rule 41 (exp -> STRING .)
    GE              reduce using rule 41 (exp -> STRING .)
    EQ              reduce using rule 41 (exp -> STRING .)
    NE              reduce using rule 41 (exp -> STRING .)
    AND             reduce using rule 41 (exp -> STRING .)
    OR              reduce using rule 41 (exp -> STRING .)
    $end            reduce using rule 41 (exp -> STRING .)
    END             reduce using rule 41 (exp -> STRING .)
    UNTIL           reduce using rule 41 (exp -> STRING .)
    ELSEIF          reduce using rule 41 (exp -> STRING .)
    ELSE            reduce using rule 41 (exp -> STRING .)
    DO              reduce using rule 41 (exp -> STRING .)
    THEN            reduce using rule 41 (exp -> STRING .)
    RPAREN          reduce using rule 41 (exp -> STRING .)
    SEMI            reduce using rule 41 (exp -> STRING .)
    RBRACE          reduce using rule 41 (exp -> STRING .)
    RETURN          reduce using rule 41 (exp -> STRING .)
    BREAK           reduce using rule 41 (exp -> STRING .)
    WHILE           reduce using rule 41 (exp -> STRING .)
    REPEAT          reduce using rule 41 (exp -> STRING .)
    IF              reduce using rule 41 (exp -> STRING .)
    FOR             reduce using rule 41 (exp -> STRING .)
    FUNCTION        reduce using rule 41 (exp -> STRING .)
    LOCAL           reduce using rule 41 (exp -> STRING .)
    NAME            reduce using rule 41 (exp -> STRING .)
    LPAREN          reduce using rule 41 (exp -> STRING .)
    RBRACK          reduce using rule 41 (exp -> STRING .)


state 31

    (42) exp -> ELLIPSIS .

    COMMA           reduce using rule 42 (exp -> ELLIPSIS .)
    PLUS            reduce using rule 42 (exp -> ELLIPSIS .)
    MINUS           reduce using rule 42 (exp -> ELLIPSIS .)
    TIMES           reduce using rule 42 (exp -> ELLIPSIS .)
    DIVIDE          reduce using rule 42 (exp -> ELLIPSIS .)
    POWER           reduce using rule 42 (exp -> ELLIPSIS .)
    MOD             reduce using rule 42 (exp -> ELLIPSIS .)
    CONCAT          reduce using rule 42 (exp -> ELLIPSIS .)
    LT              reduce using rule 42 (exp -> ELLIPSIS .)
    LE              reduce using rule 42 (exp -> ELLIPSIS .)
    GT              reduce using rule 42 (exp -> ELLIPSIS .)
    GE              reduce using rule 42 (exp -> ELLIPSIS .)
    EQ              reduce using rule 42 (exp -> ELLIPSIS .)
    NE              reduce using rule 42 (exp -> ELLIPSIS .)
    AND             reduce using rule 42 (exp -> ELLIPSIS .)
    OR              reduce using rule 42 (exp -> ELLIPSIS .)
    $end            reduce using rule 42 (exp -> ELLIPSIS .)
    END             reduce using rule 42 (exp -> ELLIPSIS .)
    UNTIL           reduce using rule 42 (exp -> ELLIPSIS .)
    ELSEIF          reduce using rule 42 (exp -> ELLIPSIS .)
    ELSE            reduce using rule 42 (exp -> ELLIPSIS .)
    DO              reduce using rule 42 (exp -> ELLIPSIS .)
    THEN            reduce using rule 42 (exp -> ELLIPSIS .)
    RPAREN          reduce using rule 42 (exp -> ELLIPSIS .)
    SEMI            reduce using rule 42 (exp -> ELLIPSIS .)
    RBRACE          reduce using rule 42 (exp -> ELLIPSIS .)
    RETURN          reduce using rule 42 (exp -> ELLIPSIS .)
    BREAK           reduce using rule 42 (exp -> ELLIPSIS .)
    WHILE           reduce using rule 42 (exp -> ELLIPSIS .)
    REPEAT          reduce using rule 42 (exp -> ELLIPSIS .)
    IF              reduce using rule 42 (exp -> ELLIPSIS .)
    FOR             reduce using rule 42 (exp -> ELLIPSIS .)
    FUNCTION        reduce using rule 42 (exp -> ELLIPSIS .)
    LOCAL           reduce using rule 42 (exp -> ELLIPSIS .)
    NAME            reduce using rule 42 (exp -> ELLIPSIS .)
    LPAREN          reduce using rule 42 (exp -> ELLIPSIS .)
    RBRACK          reduce using rule 42 (exp -> ELLIPSIS .)


state 32

    (43) exp -> function .

    COMMA           reduce using rule 43 (exp -> function .)
    PLUS            reduce using rule 43 (exp -> function .)
    MINUS           reduce using rule 43 (exp -> function .)
    TIMES           reduce using rule 43 (exp -> function .)
    DIVIDE          reduce using rule 43 (exp -> function .)
    POWER           reduce using rule 43 (exp -> function .)
    MOD             reduce using rule 43 (exp -> function .)
    CONCAT          reduce using rule 43 (exp -> function .)
    LT              reduce using rule 43 (exp -> function .)
    LE              reduce using rule 43 (exp -> function .)
    GT              reduce using rule 43 (exp -> function .)
    GE              reduce using rule 43 (exp -> function .)
    EQ              reduce using rule 43 (exp -> function .)
    NE              reduce using rule 43 (exp -> function .)
    AND             reduce using rule 43 (exp -> function .)
    OR              reduce using rule 43 (exp -> function .)
    $end            reduce using rule 43 (exp -> function .)
    END             reduce using rule 43 (exp -> function .)
    UNTIL           reduce using rule 43 (exp -> function .)
    ELSEIF          reduce using rule 43 (exp -> function .)
    ELSE            reduce using rule 43 (exp -> function .)
    DO              reduce using rule 43 (exp -> function .)
    THEN            reduce using rule 43 (exp -> function .)
    RPAREN          reduce using rule 43 (exp -> function .)
    SEMI            reduce using rule 43 (exp -> function .)
    RBRACE          reduce using rule 43 (exp -> function .)
    RETURN          reduce using rule 43 (exp -> function .)
    BREAK           reduce using rule 43 (exp -> function .)
    WHILE           reduce using rule 43 (exp -> function .)
    REPEAT          reduce using rule 43 (exp -> function .)
    IF              reduce using rule 43 (exp -> function .)
    FOR             reduce using rule 43 (exp -> function .)
    FUNCTION        reduce using rule 43 (exp -> function .)
    LOCAL           reduce using rule 43 (exp -> function .)
    NAME            reduce using rule 43 (exp -> function .)
    LPAREN          reduce using rule 43 (exp -> function .)
    RBRACK          reduce using rule 43 (exp -> function .)


state 33

    (44) exp -> prefixexp .
    (24) var -> prefixexp . LBRACK exp RBRACK
    (25) var -> prefixexp . DOT NAME
    (27) functioncall -> prefixexp . COLON NAME args

    COMMA           reduce using rule 44 (exp -> prefixexp .)
    PLUS            reduce using rule 44 (exp -> prefixexp .)
    MINUS           reduce using rule 44 (exp -> prefixexp .)
    TIMES           reduce using rule 44 (exp -> prefixexp .)
    DIVIDE          reduce using rule 44 (exp -> prefixexp .)
    POWER           reduce using rule 44 (exp -> prefixexp .)
    MOD             reduce using rule 44 (exp -> prefixexp .)
    CONCAT          reduce using rule 44 (exp -> prefixexp .)
    LT              reduce using rule 44 (exp -> prefixexp .)
    LE              reduce using rule 44 (exp -> prefixexp .)
    GT              reduce using rule 44 (exp -> prefixexp .)
    GE              reduce using rule 44 (exp -> prefixexp .)
    EQ              reduce using rule 44 (exp -> prefixexp .)
    NE              reduce using rule 44 (exp -> prefixexp .)
    AND             reduce using rule 44 (exp -> prefixexp .)
    OR              reduce using rule 44 (exp -> prefixexp .)
    $end            reduce using rule 44 (exp -> prefixexp .)
    END             reduce using rule 44 (exp -> prefixexp .)
    UNTIL           reduce using rule 44 (exp -> prefixexp .)
    ELSEIF          reduce using rule 44 (exp -> prefixexp .)
    ELSE            reduce using rule 44 (exp -> prefixexp .)
    DO              reduce using rule 44 (exp -> prefixexp .)
    THEN            reduce using rule 44 (exp -> prefixexp .)
    RPAREN          reduce using rule 44 (exp -> prefixexp .)
    SEMI            reduce using rule 44 (exp -> prefixexp .)
    RBRACE          reduce using rule 44 (exp -> prefixexp .)
    RETURN          reduce using rule 44 (exp -> prefixexp .)
    BREAK           reduce using rule 44 (exp -> prefixexp .)
    WHILE           reduce using rule 44 (exp -> prefixexp .)
    REPEAT          reduce using rule 44 (exp -> prefixexp .)
    IF              reduce using rule 44 (exp -> prefixexp .)
    FOR             reduce using rule 44 (exp -> prefixexp .)
    FUNCTION        reduce using rule 44 (exp -> prefixexp .)
    LOCAL           reduce using rule 44 (exp -> prefixexp .)
    NAME            reduce using rule 44 (exp -> prefixexp .)
    LPAREN          reduce using rule 44 (exp -> prefixexp .)
    RBRACK          reduce using rule 44 (exp -> prefixexp .)
    LBRACK          shift and go to state 63
    DOT             shift and go to state 64
    COLON           shift and go to state 62


state 34

    (45) exp -> tableconstructor .

    COMMA           reduce using rule 45 (exp -> tableconstructor .)
    PLUS            reduce using rule 45 (exp -> tableconstructor .)
    MINUS           reduce using rule 45 (exp -> tableconstructor .)
    TIMES           reduce using rule 45 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 45 (exp -> tableconstructor .)
    POWER           reduce using rule 45 (exp -> tableconstructor .)
    MOD             reduce using rule 45 (exp -> tableconstructor .)
    CONCAT          reduce using rule 45 (exp -> tableconstructor .)
    LT              reduce using rule 45 (exp -> tableconstructor .)
    LE              reduce using rule 45 (exp -> tableconstructor .)
    GT              reduce using rule 45 (exp -> tableconstructor .)
    GE              reduce using rule 45 (exp -> tableconstructor .)
    EQ              reduce using rule 45 (exp -> tableconstructor .)
    NE              reduce using rule 45 (exp -> tableconstructor .)
    AND             reduce using rule 45 (exp -> tableconstructor .)
    OR              reduce using rule 45 (exp -> tableconstructor .)
    $end            reduce using rule 45 (exp -> tableconstructor .)
    END             reduce using rule 45 (exp -> tableconstructor .)
    UNTIL           reduce using rule 45 (exp -> tableconstructor .)
    ELSEIF          reduce using rule 45 (exp -> tableconstructor .)
    ELSE            reduce using rule 45 (exp -> tableconstructor .)
    DO              reduce using rule 45 (exp -> tableconstructor .)
    THEN            reduce using rule 45 (exp -> tableconstructor .)
    RPAREN          reduce using rule 45 (exp -> tableconstructor .)
    SEMI            reduce using rule 45 (exp -> tableconstructor .)
    RBRACE          reduce using rule 45 (exp -> tableconstructor .)
    RETURN          reduce using rule 45 (exp -> tableconstructor .)
    BREAK           reduce using rule 45 (exp -> tableconstructor .)
    WHILE           reduce using rule 45 (exp -> tableconstructor .)
    REPEAT          reduce using rule 45 (exp -> tableconstructor .)
    IF              reduce using rule 45 (exp -> tableconstructor .)
    FOR             reduce using rule 45 (exp -> tableconstructor .)
    FUNCTION        reduce using rule 45 (exp -> tableconstructor .)
    LOCAL           reduce using rule 45 (exp -> tableconstructor .)
    NAME            reduce using rule 45 (exp -> tableconstructor .)
    LPAREN          reduce using rule 45 (exp -> tableconstructor .)
    RBRACK          reduce using rule 45 (exp -> tableconstructor .)


state 35

    (47) exp -> unop . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    unop                           shift and go to state 35
    exp                            shift and go to state 84
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 36

    (51) function -> FUNCTION . funcbody
    (52) funcbody -> . LPAREN opt_parlist RPAREN block END

    LPAREN          shift and go to state 86

    funcbody                       shift and go to state 85

state 37

    (48) prefixexp -> var .

    LBRACK          reduce using rule 48 (prefixexp -> var .)
    DOT             reduce using rule 48 (prefixexp -> var .)
    COLON           reduce using rule 48 (prefixexp -> var .)
    COMMA           reduce using rule 48 (prefixexp -> var .)
    PLUS            reduce using rule 48 (prefixexp -> var .)
    MINUS           reduce using rule 48 (prefixexp -> var .)
    TIMES           reduce using rule 48 (prefixexp -> var .)
    DIVIDE          reduce using rule 48 (prefixexp -> var .)
    POWER           reduce using rule 48 (prefixexp -> var .)
    MOD             reduce using rule 48 (prefixexp -> var .)
    CONCAT          reduce using rule 48 (prefixexp -> var .)
    LT              reduce using rule 48 (prefixexp -> var .)
    LE              reduce using rule 48 (prefixexp -> var .)
    GT              reduce using rule 48 (prefixexp -> var .)
    GE              reduce using rule 48 (prefixexp -> var .)
    EQ              reduce using rule 48 (prefixexp -> var .)
    NE              reduce using rule 48 (prefixexp -> var .)
    AND             reduce using rule 48 (prefixexp -> var .)
    OR              reduce using rule 48 (prefixexp -> var .)
    $end            reduce using rule 48 (prefixexp -> var .)
    END             reduce using rule 48 (prefixexp -> var .)
    UNTIL           reduce using rule 48 (prefixexp -> var .)
    ELSEIF          reduce using rule 48 (prefixexp -> var .)
    ELSE            reduce using rule 48 (prefixexp -> var .)
    DO              reduce using rule 48 (prefixexp -> var .)
    THEN            reduce using rule 48 (prefixexp -> var .)
    RPAREN          reduce using rule 48 (prefixexp -> var .)
    SEMI            reduce using rule 48 (prefixexp -> var .)
    RBRACE          reduce using rule 48 (prefixexp -> var .)
    RETURN          reduce using rule 48 (prefixexp -> var .)
    BREAK           reduce using rule 48 (prefixexp -> var .)
    WHILE           reduce using rule 48 (prefixexp -> var .)
    REPEAT          reduce using rule 48 (prefixexp -> var .)
    IF              reduce using rule 48 (prefixexp -> var .)
    FOR             reduce using rule 48 (prefixexp -> var .)
    FUNCTION        reduce using rule 48 (prefixexp -> var .)
    LOCAL           reduce using rule 48 (prefixexp -> var .)
    NAME            reduce using rule 48 (prefixexp -> var .)
    LPAREN          reduce using rule 48 (prefixexp -> var .)
    RBRACK          reduce using rule 48 (prefixexp -> var .)


state 38

    (49) prefixexp -> functioncall .

    LBRACK          reduce using rule 49 (prefixexp -> functioncall .)
    DOT             reduce using rule 49 (prefixexp -> functioncall .)
    COLON           reduce using rule 49 (prefixexp -> functioncall .)
    COMMA           reduce using rule 49 (prefixexp -> functioncall .)
    PLUS            reduce using rule 49 (prefixexp -> functioncall .)
    MINUS           reduce using rule 49 (prefixexp -> functioncall .)
    TIMES           reduce using rule 49 (prefixexp -> functioncall .)
    DIVIDE          reduce using rule 49 (prefixexp -> functioncall .)
    POWER           reduce using rule 49 (prefixexp -> functioncall .)
    MOD             reduce using rule 49 (prefixexp -> functioncall .)
    CONCAT          reduce using rule 49 (prefixexp -> functioncall .)
    LT              reduce using rule 49 (prefixexp -> functioncall .)
    LE              reduce using rule 49 (prefixexp -> functioncall .)
    GT              reduce using rule 49 (prefixexp -> functioncall .)
    GE              reduce using rule 49 (prefixexp -> functioncall .)
    EQ              reduce using rule 49 (prefixexp -> functioncall .)
    NE              reduce using rule 49 (prefixexp -> functioncall .)
    AND             reduce using rule 49 (prefixexp -> functioncall .)
    OR              reduce using rule 49 (prefixexp -> functioncall .)
    $end            reduce using rule 49 (prefixexp -> functioncall .)
    END             reduce using rule 49 (prefixexp -> functioncall .)
    UNTIL           reduce using rule 49 (prefixexp -> functioncall .)
    ELSEIF          reduce using rule 49 (prefixexp -> functioncall .)
    ELSE            reduce using rule 49 (prefixexp -> functioncall .)
    DO              reduce using rule 49 (prefixexp -> functioncall .)
    THEN            reduce using rule 49 (prefixexp -> functioncall .)
    RPAREN          reduce using rule 49 (prefixexp -> functioncall .)
    SEMI            reduce using rule 49 (prefixexp -> functioncall .)
    RBRACE          reduce using rule 49 (prefixexp -> functioncall .)
    RETURN          reduce using rule 49 (prefixexp -> functioncall .)
    BREAK           reduce using rule 49 (prefixexp -> functioncall .)
    WHILE           reduce using rule 49 (prefixexp -> functioncall .)
    REPEAT          reduce using rule 49 (prefixexp -> functioncall .)
    IF              reduce using rule 49 (prefixexp -> functioncall .)
    FOR             reduce using rule 49 (prefixexp -> functioncall .)
    FUNCTION        reduce using rule 49 (prefixexp -> functioncall .)
    LOCAL           reduce using rule 49 (prefixexp -> functioncall .)
    NAME            reduce using rule 49 (prefixexp -> functioncall .)
    LPAREN          reduce using rule 49 (prefixexp -> functioncall .)
    RBRACK          reduce using rule 49 (prefixexp -> functioncall .)


state 39

    (55) tableconstructor -> LBRACE . opt_fieldlist RBRACE
    (88) opt_fieldlist -> . fieldlist
    (89) opt_fieldlist -> . empty
    (56) fieldlist -> . field field_tail
    (103) empty -> .
    (59) field -> . LBRACK exp RBRACK ASSIGN exp
    (60) field -> . NAME ASSIGN exp
    (61) field -> . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    RBRACE          reduce using rule 103 (empty -> .)
    LBRACK          shift and go to state 91
    NAME            shift and go to state 93
    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42

    opt_fieldlist                  shift and go to state 87
    fieldlist                      shift and go to state 88
    empty                          shift and go to state 89
    field                          shift and go to state 90
    exp                            shift and go to state 92
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 40

    (79) unop -> MINUS .

    NIL             reduce using rule 79 (unop -> MINUS .)
    FALSE           reduce using rule 79 (unop -> MINUS .)
    TRUE            reduce using rule 79 (unop -> MINUS .)
    NUMBER          reduce using rule 79 (unop -> MINUS .)
    STRING          reduce using rule 79 (unop -> MINUS .)
    ELLIPSIS        reduce using rule 79 (unop -> MINUS .)
    FUNCTION        reduce using rule 79 (unop -> MINUS .)
    LPAREN          reduce using rule 79 (unop -> MINUS .)
    LBRACE          reduce using rule 79 (unop -> MINUS .)
    MINUS           reduce using rule 79 (unop -> MINUS .)
    NOT             reduce using rule 79 (unop -> MINUS .)
    LEN             reduce using rule 79 (unop -> MINUS .)
    NAME            reduce using rule 79 (unop -> MINUS .)


state 41

    (80) unop -> NOT .

    NIL             reduce using rule 80 (unop -> NOT .)
    FALSE           reduce using rule 80 (unop -> NOT .)
    TRUE            reduce using rule 80 (unop -> NOT .)
    NUMBER          reduce using rule 80 (unop -> NOT .)
    STRING          reduce using rule 80 (unop -> NOT .)
    ELLIPSIS        reduce using rule 80 (unop -> NOT .)
    FUNCTION        reduce using rule 80 (unop -> NOT .)
    LPAREN          reduce using rule 80 (unop -> NOT .)
    LBRACE          reduce using rule 80 (unop -> NOT .)
    MINUS           reduce using rule 80 (unop -> NOT .)
    NOT             reduce using rule 80 (unop -> NOT .)
    LEN             reduce using rule 80 (unop -> NOT .)
    NAME            reduce using rule 80 (unop -> NOT .)


state 42

    (81) unop -> LEN .

    NIL             reduce using rule 81 (unop -> LEN .)
    FALSE           reduce using rule 81 (unop -> LEN .)
    TRUE            reduce using rule 81 (unop -> LEN .)
    NUMBER          reduce using rule 81 (unop -> LEN .)
    STRING          reduce using rule 81 (unop -> LEN .)
    ELLIPSIS        reduce using rule 81 (unop -> LEN .)
    FUNCTION        reduce using rule 81 (unop -> LEN .)
    LPAREN          reduce using rule 81 (unop -> LEN .)
    LBRACE          reduce using rule 81 (unop -> LEN .)
    MINUS           reduce using rule 81 (unop -> LEN .)
    NOT             reduce using rule 81 (unop -> LEN .)
    LEN             reduce using rule 81 (unop -> LEN .)
    NAME            reduce using rule 81 (unop -> LEN .)


state 43

    (23) var -> NAME .
    (26) functioncall -> NAME . LPAREN opt_explist RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACK          reduce using rule 23 (var -> NAME .)
    DOT             reduce using rule 23 (var -> NAME .)
    COLON           reduce using rule 23 (var -> NAME .)
    COMMA           reduce using rule 23 (var -> NAME .)
    PLUS            reduce using rule 23 (var -> NAME .)
    MINUS           reduce using rule 23 (var -> NAME .)
    TIMES           reduce using rule 23 (var -> NAME .)
    DIVIDE          reduce using rule 23 (var -> NAME .)
    POWER           reduce using rule 23 (var -> NAME .)
    MOD             reduce using rule 23 (var -> NAME .)
    CONCAT          reduce using rule 23 (var -> NAME .)
    LT              reduce using rule 23 (var -> NAME .)
    LE              reduce using rule 23 (var -> NAME .)
    GT              reduce using rule 23 (var -> NAME .)
    GE              reduce using rule 23 (var -> NAME .)
    EQ              reduce using rule 23 (var -> NAME .)
    NE              reduce using rule 23 (var -> NAME .)
    AND             reduce using rule 23 (var -> NAME .)
    OR              reduce using rule 23 (var -> NAME .)
    $end            reduce using rule 23 (var -> NAME .)
    END             reduce using rule 23 (var -> NAME .)
    UNTIL           reduce using rule 23 (var -> NAME .)
    ELSEIF          reduce using rule 23 (var -> NAME .)
    ELSE            reduce using rule 23 (var -> NAME .)
    DO              reduce using rule 23 (var -> NAME .)
    THEN            reduce using rule 23 (var -> NAME .)
    RPAREN          reduce using rule 23 (var -> NAME .)
    SEMI            reduce using rule 23 (var -> NAME .)
    RBRACE          reduce using rule 23 (var -> NAME .)
    RETURN          reduce using rule 23 (var -> NAME .)
    BREAK           reduce using rule 23 (var -> NAME .)
    WHILE           reduce using rule 23 (var -> NAME .)
    REPEAT          reduce using rule 23 (var -> NAME .)
    IF              reduce using rule 23 (var -> NAME .)
    FOR             reduce using rule 23 (var -> NAME .)
    FUNCTION        reduce using rule 23 (var -> NAME .)
    LOCAL           reduce using rule 23 (var -> NAME .)
    NAME            reduce using rule 23 (var -> NAME .)
    RBRACK          reduce using rule 23 (var -> NAME .)
    ASSIGN          reduce using rule 23 (var -> NAME .)
    LPAREN          shift and go to state 52

  ! LPAREN          [ reduce using rule 23 (var -> NAME .) ]


state 44

    (6) stat -> varlist ASSIGN . explist
    (34) explist -> . exp exp_tail
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    explist                        shift and go to state 94
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 45

    (8) stat -> DO block . END

    END             shift and go to state 95


state 46

    (102) block -> chunk .

    END             reduce using rule 102 (block -> chunk .)
    UNTIL           reduce using rule 102 (block -> chunk .)
    ELSEIF          reduce using rule 102 (block -> chunk .)
    ELSE            reduce using rule 102 (block -> chunk .)


state 47

    (9) stat -> WHILE exp . DO block END
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    DO              shift and go to state 96
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 48

    (10) stat -> REPEAT block . UNTIL exp

    UNTIL           shift and go to state 97


state 49

    (11) stat -> IF exp . THEN block elseiflist opt_else END
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    THEN            shift and go to state 98
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 50

    (12) stat -> FOR NAME . ASSIGN exp COMMA exp opt_comma_exp DO block END
    (31) namelist -> NAME . namelist_tail
    (32) namelist_tail -> . COMMA NAME namelist_tail
    (33) namelist_tail -> . empty
    (103) empty -> .

    ASSIGN          shift and go to state 99
    COMMA           shift and go to state 100
    IN              reduce using rule 103 (empty -> .)

    namelist_tail                  shift and go to state 101
    empty                          shift and go to state 102

state 51

    (13) stat -> FOR namelist . IN explist DO block END

    IN              shift and go to state 103


state 52

    (26) functioncall -> NAME LPAREN . opt_explist RPAREN
    (82) opt_explist -> . explist
    (83) opt_explist -> . empty
    (34) explist -> . exp exp_tail
    (103) empty -> .
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    RPAREN          reduce using rule 103 (empty -> .)
    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    opt_explist                    shift and go to state 104
    explist                        shift and go to state 23
    empty                          shift and go to state 24
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 53

    (14) stat -> FUNCTION funcname . funcbody
    (52) funcbody -> . LPAREN opt_parlist RPAREN block END

    LPAREN          shift and go to state 86

    funcbody                       shift and go to state 105

state 54

    (19) funcname -> NAME . nameparts opt_colon_name
    (98) nameparts -> . DOT NAME nameparts
    (99) nameparts -> . empty
    (103) empty -> .

    DOT             shift and go to state 107
    COLON           reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)

    nameparts                      shift and go to state 106
    empty                          shift and go to state 108

state 55

    (15) stat -> LOCAL FUNCTION . NAME funcbody

    NAME            shift and go to state 109


state 56

    (31) namelist -> NAME . namelist_tail
    (32) namelist_tail -> . COMMA NAME namelist_tail
    (33) namelist_tail -> . empty
    (103) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 100
    ASSIGN          reduce using rule 103 (empty -> .)
    SEMI            reduce using rule 103 (empty -> .)
    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    RPAREN          reduce using rule 103 (empty -> .)

  ! COMMA           [ reduce using rule 103 (empty -> .) ]

    namelist_tail                  shift and go to state 101
    empty                          shift and go to state 102

state 57

    (16) stat -> LOCAL namelist . opt_assign
    (86) opt_assign -> . ASSIGN explist
    (87) opt_assign -> . empty
    (103) empty -> .

    ASSIGN          shift and go to state 111
    SEMI            reduce using rule 103 (empty -> .)
    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)

    opt_assign                     shift and go to state 110
    empty                          shift and go to state 112

state 58

    (20) varlist -> var varlist_tail .

    ASSIGN          reduce using rule 20 (varlist -> var varlist_tail .)


state 59

    (21) varlist_tail -> COMMA . var varlist_tail
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NAME            shift and go to state 43
    LPAREN          shift and go to state 19

    var                            shift and go to state 113
    prefixexp                      shift and go to state 114
    functioncall                   shift and go to state 38

state 60

    (22) varlist_tail -> empty .

    ASSIGN          reduce using rule 22 (varlist_tail -> empty .)


state 61

    (50) prefixexp -> LPAREN exp . RPAREN
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    RPAREN          shift and go to state 115
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 62

    (27) functioncall -> prefixexp COLON . NAME args

    NAME            shift and go to state 116


state 63

    (24) var -> prefixexp LBRACK . exp RBRACK
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    prefixexp                      shift and go to state 33
    exp                            shift and go to state 117
    function                       shift and go to state 32
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 64

    (25) var -> prefixexp DOT . NAME

    NAME            shift and go to state 118


state 65

    (34) explist -> exp exp_tail .

    $end            reduce using rule 34 (explist -> exp exp_tail .)
    END             reduce using rule 34 (explist -> exp exp_tail .)
    UNTIL           reduce using rule 34 (explist -> exp exp_tail .)
    ELSEIF          reduce using rule 34 (explist -> exp exp_tail .)
    ELSE            reduce using rule 34 (explist -> exp exp_tail .)
    SEMI            reduce using rule 34 (explist -> exp exp_tail .)
    RETURN          reduce using rule 34 (explist -> exp exp_tail .)
    BREAK           reduce using rule 34 (explist -> exp exp_tail .)
    DO              reduce using rule 34 (explist -> exp exp_tail .)
    WHILE           reduce using rule 34 (explist -> exp exp_tail .)
    REPEAT          reduce using rule 34 (explist -> exp exp_tail .)
    IF              reduce using rule 34 (explist -> exp exp_tail .)
    FOR             reduce using rule 34 (explist -> exp exp_tail .)
    FUNCTION        reduce using rule 34 (explist -> exp exp_tail .)
    LOCAL           reduce using rule 34 (explist -> exp exp_tail .)
    NAME            reduce using rule 34 (explist -> exp exp_tail .)
    LPAREN          reduce using rule 34 (explist -> exp exp_tail .)
    RPAREN          reduce using rule 34 (explist -> exp exp_tail .)


state 66

    (46) exp -> exp binop . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 119
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 67

    (35) exp_tail -> COMMA . exp exp_tail
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 120
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 68

    (36) exp_tail -> empty .

    $end            reduce using rule 36 (exp_tail -> empty .)
    END             reduce using rule 36 (exp_tail -> empty .)
    UNTIL           reduce using rule 36 (exp_tail -> empty .)
    ELSEIF          reduce using rule 36 (exp_tail -> empty .)
    ELSE            reduce using rule 36 (exp_tail -> empty .)
    SEMI            reduce using rule 36 (exp_tail -> empty .)
    RETURN          reduce using rule 36 (exp_tail -> empty .)
    BREAK           reduce using rule 36 (exp_tail -> empty .)
    DO              reduce using rule 36 (exp_tail -> empty .)
    WHILE           reduce using rule 36 (exp_tail -> empty .)
    REPEAT          reduce using rule 36 (exp_tail -> empty .)
    IF              reduce using rule 36 (exp_tail -> empty .)
    FOR             reduce using rule 36 (exp_tail -> empty .)
    FUNCTION        reduce using rule 36 (exp_tail -> empty .)
    LOCAL           reduce using rule 36 (exp_tail -> empty .)
    NAME            reduce using rule 36 (exp_tail -> empty .)
    LPAREN          reduce using rule 36 (exp_tail -> empty .)
    RPAREN          reduce using rule 36 (exp_tail -> empty .)


state 69

    (64) binop -> PLUS .

    NIL             reduce using rule 64 (binop -> PLUS .)
    FALSE           reduce using rule 64 (binop -> PLUS .)
    TRUE            reduce using rule 64 (binop -> PLUS .)
    NUMBER          reduce using rule 64 (binop -> PLUS .)
    STRING          reduce using rule 64 (binop -> PLUS .)
    ELLIPSIS        reduce using rule 64 (binop -> PLUS .)
    FUNCTION        reduce using rule 64 (binop -> PLUS .)
    LPAREN          reduce using rule 64 (binop -> PLUS .)
    LBRACE          reduce using rule 64 (binop -> PLUS .)
    MINUS           reduce using rule 64 (binop -> PLUS .)
    NOT             reduce using rule 64 (binop -> PLUS .)
    LEN             reduce using rule 64 (binop -> PLUS .)
    NAME            reduce using rule 64 (binop -> PLUS .)


state 70

    (65) binop -> MINUS .

    NIL             reduce using rule 65 (binop -> MINUS .)
    FALSE           reduce using rule 65 (binop -> MINUS .)
    TRUE            reduce using rule 65 (binop -> MINUS .)
    NUMBER          reduce using rule 65 (binop -> MINUS .)
    STRING          reduce using rule 65 (binop -> MINUS .)
    ELLIPSIS        reduce using rule 65 (binop -> MINUS .)
    FUNCTION        reduce using rule 65 (binop -> MINUS .)
    LPAREN          reduce using rule 65 (binop -> MINUS .)
    LBRACE          reduce using rule 65 (binop -> MINUS .)
    MINUS           reduce using rule 65 (binop -> MINUS .)
    NOT             reduce using rule 65 (binop -> MINUS .)
    LEN             reduce using rule 65 (binop -> MINUS .)
    NAME            reduce using rule 65 (binop -> MINUS .)


state 71

    (66) binop -> TIMES .

    NIL             reduce using rule 66 (binop -> TIMES .)
    FALSE           reduce using rule 66 (binop -> TIMES .)
    TRUE            reduce using rule 66 (binop -> TIMES .)
    NUMBER          reduce using rule 66 (binop -> TIMES .)
    STRING          reduce using rule 66 (binop -> TIMES .)
    ELLIPSIS        reduce using rule 66 (binop -> TIMES .)
    FUNCTION        reduce using rule 66 (binop -> TIMES .)
    LPAREN          reduce using rule 66 (binop -> TIMES .)
    LBRACE          reduce using rule 66 (binop -> TIMES .)
    MINUS           reduce using rule 66 (binop -> TIMES .)
    NOT             reduce using rule 66 (binop -> TIMES .)
    LEN             reduce using rule 66 (binop -> TIMES .)
    NAME            reduce using rule 66 (binop -> TIMES .)


state 72

    (67) binop -> DIVIDE .

    NIL             reduce using rule 67 (binop -> DIVIDE .)
    FALSE           reduce using rule 67 (binop -> DIVIDE .)
    TRUE            reduce using rule 67 (binop -> DIVIDE .)
    NUMBER          reduce using rule 67 (binop -> DIVIDE .)
    STRING          reduce using rule 67 (binop -> DIVIDE .)
    ELLIPSIS        reduce using rule 67 (binop -> DIVIDE .)
    FUNCTION        reduce using rule 67 (binop -> DIVIDE .)
    LPAREN          reduce using rule 67 (binop -> DIVIDE .)
    LBRACE          reduce using rule 67 (binop -> DIVIDE .)
    MINUS           reduce using rule 67 (binop -> DIVIDE .)
    NOT             reduce using rule 67 (binop -> DIVIDE .)
    LEN             reduce using rule 67 (binop -> DIVIDE .)
    NAME            reduce using rule 67 (binop -> DIVIDE .)


state 73

    (68) binop -> POWER .

    NIL             reduce using rule 68 (binop -> POWER .)
    FALSE           reduce using rule 68 (binop -> POWER .)
    TRUE            reduce using rule 68 (binop -> POWER .)
    NUMBER          reduce using rule 68 (binop -> POWER .)
    STRING          reduce using rule 68 (binop -> POWER .)
    ELLIPSIS        reduce using rule 68 (binop -> POWER .)
    FUNCTION        reduce using rule 68 (binop -> POWER .)
    LPAREN          reduce using rule 68 (binop -> POWER .)
    LBRACE          reduce using rule 68 (binop -> POWER .)
    MINUS           reduce using rule 68 (binop -> POWER .)
    NOT             reduce using rule 68 (binop -> POWER .)
    LEN             reduce using rule 68 (binop -> POWER .)
    NAME            reduce using rule 68 (binop -> POWER .)


state 74

    (69) binop -> MOD .

    NIL             reduce using rule 69 (binop -> MOD .)
    FALSE           reduce using rule 69 (binop -> MOD .)
    TRUE            reduce using rule 69 (binop -> MOD .)
    NUMBER          reduce using rule 69 (binop -> MOD .)
    STRING          reduce using rule 69 (binop -> MOD .)
    ELLIPSIS        reduce using rule 69 (binop -> MOD .)
    FUNCTION        reduce using rule 69 (binop -> MOD .)
    LPAREN          reduce using rule 69 (binop -> MOD .)
    LBRACE          reduce using rule 69 (binop -> MOD .)
    MINUS           reduce using rule 69 (binop -> MOD .)
    NOT             reduce using rule 69 (binop -> MOD .)
    LEN             reduce using rule 69 (binop -> MOD .)
    NAME            reduce using rule 69 (binop -> MOD .)


state 75

    (70) binop -> CONCAT .

    NIL             reduce using rule 70 (binop -> CONCAT .)
    FALSE           reduce using rule 70 (binop -> CONCAT .)
    TRUE            reduce using rule 70 (binop -> CONCAT .)
    NUMBER          reduce using rule 70 (binop -> CONCAT .)
    STRING          reduce using rule 70 (binop -> CONCAT .)
    ELLIPSIS        reduce using rule 70 (binop -> CONCAT .)
    FUNCTION        reduce using rule 70 (binop -> CONCAT .)
    LPAREN          reduce using rule 70 (binop -> CONCAT .)
    LBRACE          reduce using rule 70 (binop -> CONCAT .)
    MINUS           reduce using rule 70 (binop -> CONCAT .)
    NOT             reduce using rule 70 (binop -> CONCAT .)
    LEN             reduce using rule 70 (binop -> CONCAT .)
    NAME            reduce using rule 70 (binop -> CONCAT .)


state 76

    (71) binop -> LT .

    NIL             reduce using rule 71 (binop -> LT .)
    FALSE           reduce using rule 71 (binop -> LT .)
    TRUE            reduce using rule 71 (binop -> LT .)
    NUMBER          reduce using rule 71 (binop -> LT .)
    STRING          reduce using rule 71 (binop -> LT .)
    ELLIPSIS        reduce using rule 71 (binop -> LT .)
    FUNCTION        reduce using rule 71 (binop -> LT .)
    LPAREN          reduce using rule 71 (binop -> LT .)
    LBRACE          reduce using rule 71 (binop -> LT .)
    MINUS           reduce using rule 71 (binop -> LT .)
    NOT             reduce using rule 71 (binop -> LT .)
    LEN             reduce using rule 71 (binop -> LT .)
    NAME            reduce using rule 71 (binop -> LT .)


state 77

    (72) binop -> LE .

    NIL             reduce using rule 72 (binop -> LE .)
    FALSE           reduce using rule 72 (binop -> LE .)
    TRUE            reduce using rule 72 (binop -> LE .)
    NUMBER          reduce using rule 72 (binop -> LE .)
    STRING          reduce using rule 72 (binop -> LE .)
    ELLIPSIS        reduce using rule 72 (binop -> LE .)
    FUNCTION        reduce using rule 72 (binop -> LE .)
    LPAREN          reduce using rule 72 (binop -> LE .)
    LBRACE          reduce using rule 72 (binop -> LE .)
    MINUS           reduce using rule 72 (binop -> LE .)
    NOT             reduce using rule 72 (binop -> LE .)
    LEN             reduce using rule 72 (binop -> LE .)
    NAME            reduce using rule 72 (binop -> LE .)


state 78

    (73) binop -> GT .

    NIL             reduce using rule 73 (binop -> GT .)
    FALSE           reduce using rule 73 (binop -> GT .)
    TRUE            reduce using rule 73 (binop -> GT .)
    NUMBER          reduce using rule 73 (binop -> GT .)
    STRING          reduce using rule 73 (binop -> GT .)
    ELLIPSIS        reduce using rule 73 (binop -> GT .)
    FUNCTION        reduce using rule 73 (binop -> GT .)
    LPAREN          reduce using rule 73 (binop -> GT .)
    LBRACE          reduce using rule 73 (binop -> GT .)
    MINUS           reduce using rule 73 (binop -> GT .)
    NOT             reduce using rule 73 (binop -> GT .)
    LEN             reduce using rule 73 (binop -> GT .)
    NAME            reduce using rule 73 (binop -> GT .)


state 79

    (74) binop -> GE .

    NIL             reduce using rule 74 (binop -> GE .)
    FALSE           reduce using rule 74 (binop -> GE .)
    TRUE            reduce using rule 74 (binop -> GE .)
    NUMBER          reduce using rule 74 (binop -> GE .)
    STRING          reduce using rule 74 (binop -> GE .)
    ELLIPSIS        reduce using rule 74 (binop -> GE .)
    FUNCTION        reduce using rule 74 (binop -> GE .)
    LPAREN          reduce using rule 74 (binop -> GE .)
    LBRACE          reduce using rule 74 (binop -> GE .)
    MINUS           reduce using rule 74 (binop -> GE .)
    NOT             reduce using rule 74 (binop -> GE .)
    LEN             reduce using rule 74 (binop -> GE .)
    NAME            reduce using rule 74 (binop -> GE .)


state 80

    (75) binop -> EQ .

    NIL             reduce using rule 75 (binop -> EQ .)
    FALSE           reduce using rule 75 (binop -> EQ .)
    TRUE            reduce using rule 75 (binop -> EQ .)
    NUMBER          reduce using rule 75 (binop -> EQ .)
    STRING          reduce using rule 75 (binop -> EQ .)
    ELLIPSIS        reduce using rule 75 (binop -> EQ .)
    FUNCTION        reduce using rule 75 (binop -> EQ .)
    LPAREN          reduce using rule 75 (binop -> EQ .)
    LBRACE          reduce using rule 75 (binop -> EQ .)
    MINUS           reduce using rule 75 (binop -> EQ .)
    NOT             reduce using rule 75 (binop -> EQ .)
    LEN             reduce using rule 75 (binop -> EQ .)
    NAME            reduce using rule 75 (binop -> EQ .)


state 81

    (76) binop -> NE .

    NIL             reduce using rule 76 (binop -> NE .)
    FALSE           reduce using rule 76 (binop -> NE .)
    TRUE            reduce using rule 76 (binop -> NE .)
    NUMBER          reduce using rule 76 (binop -> NE .)
    STRING          reduce using rule 76 (binop -> NE .)
    ELLIPSIS        reduce using rule 76 (binop -> NE .)
    FUNCTION        reduce using rule 76 (binop -> NE .)
    LPAREN          reduce using rule 76 (binop -> NE .)
    LBRACE          reduce using rule 76 (binop -> NE .)
    MINUS           reduce using rule 76 (binop -> NE .)
    NOT             reduce using rule 76 (binop -> NE .)
    LEN             reduce using rule 76 (binop -> NE .)
    NAME            reduce using rule 76 (binop -> NE .)


state 82

    (77) binop -> AND .

    NIL             reduce using rule 77 (binop -> AND .)
    FALSE           reduce using rule 77 (binop -> AND .)
    TRUE            reduce using rule 77 (binop -> AND .)
    NUMBER          reduce using rule 77 (binop -> AND .)
    STRING          reduce using rule 77 (binop -> AND .)
    ELLIPSIS        reduce using rule 77 (binop -> AND .)
    FUNCTION        reduce using rule 77 (binop -> AND .)
    LPAREN          reduce using rule 77 (binop -> AND .)
    LBRACE          reduce using rule 77 (binop -> AND .)
    MINUS           reduce using rule 77 (binop -> AND .)
    NOT             reduce using rule 77 (binop -> AND .)
    LEN             reduce using rule 77 (binop -> AND .)
    NAME            reduce using rule 77 (binop -> AND .)


state 83

    (78) binop -> OR .

    NIL             reduce using rule 78 (binop -> OR .)
    FALSE           reduce using rule 78 (binop -> OR .)
    TRUE            reduce using rule 78 (binop -> OR .)
    NUMBER          reduce using rule 78 (binop -> OR .)
    STRING          reduce using rule 78 (binop -> OR .)
    ELLIPSIS        reduce using rule 78 (binop -> OR .)
    FUNCTION        reduce using rule 78 (binop -> OR .)
    LPAREN          reduce using rule 78 (binop -> OR .)
    LBRACE          reduce using rule 78 (binop -> OR .)
    MINUS           reduce using rule 78 (binop -> OR .)
    NOT             reduce using rule 78 (binop -> OR .)
    LEN             reduce using rule 78 (binop -> OR .)
    NAME            reduce using rule 78 (binop -> OR .)


state 84

    (47) exp -> unop exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 47 (exp -> unop exp .)
    $end            reduce using rule 47 (exp -> unop exp .)
    END             reduce using rule 47 (exp -> unop exp .)
    UNTIL           reduce using rule 47 (exp -> unop exp .)
    ELSEIF          reduce using rule 47 (exp -> unop exp .)
    ELSE            reduce using rule 47 (exp -> unop exp .)
    DO              reduce using rule 47 (exp -> unop exp .)
    THEN            reduce using rule 47 (exp -> unop exp .)
    RPAREN          reduce using rule 47 (exp -> unop exp .)
    SEMI            reduce using rule 47 (exp -> unop exp .)
    RBRACE          reduce using rule 47 (exp -> unop exp .)
    RETURN          reduce using rule 47 (exp -> unop exp .)
    BREAK           reduce using rule 47 (exp -> unop exp .)
    WHILE           reduce using rule 47 (exp -> unop exp .)
    REPEAT          reduce using rule 47 (exp -> unop exp .)
    IF              reduce using rule 47 (exp -> unop exp .)
    FOR             reduce using rule 47 (exp -> unop exp .)
    FUNCTION        reduce using rule 47 (exp -> unop exp .)
    LOCAL           reduce using rule 47 (exp -> unop exp .)
    NAME            reduce using rule 47 (exp -> unop exp .)
    LPAREN          reduce using rule 47 (exp -> unop exp .)
    RBRACK          reduce using rule 47 (exp -> unop exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

  ! PLUS            [ reduce using rule 47 (exp -> unop exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> unop exp .) ]
  ! TIMES           [ reduce using rule 47 (exp -> unop exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> unop exp .) ]
  ! POWER           [ reduce using rule 47 (exp -> unop exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> unop exp .) ]
  ! CONCAT          [ reduce using rule 47 (exp -> unop exp .) ]
  ! LT              [ reduce using rule 47 (exp -> unop exp .) ]
  ! LE              [ reduce using rule 47 (exp -> unop exp .) ]
  ! GT              [ reduce using rule 47 (exp -> unop exp .) ]
  ! GE              [ reduce using rule 47 (exp -> unop exp .) ]
  ! EQ              [ reduce using rule 47 (exp -> unop exp .) ]
  ! NE              [ reduce using rule 47 (exp -> unop exp .) ]
  ! AND             [ reduce using rule 47 (exp -> unop exp .) ]
  ! OR              [ reduce using rule 47 (exp -> unop exp .) ]

    binop                          shift and go to state 66

state 85

    (51) function -> FUNCTION funcbody .

    COMMA           reduce using rule 51 (function -> FUNCTION funcbody .)
    PLUS            reduce using rule 51 (function -> FUNCTION funcbody .)
    MINUS           reduce using rule 51 (function -> FUNCTION funcbody .)
    TIMES           reduce using rule 51 (function -> FUNCTION funcbody .)
    DIVIDE          reduce using rule 51 (function -> FUNCTION funcbody .)
    POWER           reduce using rule 51 (function -> FUNCTION funcbody .)
    MOD             reduce using rule 51 (function -> FUNCTION funcbody .)
    CONCAT          reduce using rule 51 (function -> FUNCTION funcbody .)
    LT              reduce using rule 51 (function -> FUNCTION funcbody .)
    LE              reduce using rule 51 (function -> FUNCTION funcbody .)
    GT              reduce using rule 51 (function -> FUNCTION funcbody .)
    GE              reduce using rule 51 (function -> FUNCTION funcbody .)
    EQ              reduce using rule 51 (function -> FUNCTION funcbody .)
    NE              reduce using rule 51 (function -> FUNCTION funcbody .)
    AND             reduce using rule 51 (function -> FUNCTION funcbody .)
    OR              reduce using rule 51 (function -> FUNCTION funcbody .)
    $end            reduce using rule 51 (function -> FUNCTION funcbody .)
    END             reduce using rule 51 (function -> FUNCTION funcbody .)
    UNTIL           reduce using rule 51 (function -> FUNCTION funcbody .)
    ELSEIF          reduce using rule 51 (function -> FUNCTION funcbody .)
    ELSE            reduce using rule 51 (function -> FUNCTION funcbody .)
    DO              reduce using rule 51 (function -> FUNCTION funcbody .)
    THEN            reduce using rule 51 (function -> FUNCTION funcbody .)
    RPAREN          reduce using rule 51 (function -> FUNCTION funcbody .)
    SEMI            reduce using rule 51 (function -> FUNCTION funcbody .)
    RBRACE          reduce using rule 51 (function -> FUNCTION funcbody .)
    RETURN          reduce using rule 51 (function -> FUNCTION funcbody .)
    BREAK           reduce using rule 51 (function -> FUNCTION funcbody .)
    WHILE           reduce using rule 51 (function -> FUNCTION funcbody .)
    REPEAT          reduce using rule 51 (function -> FUNCTION funcbody .)
    IF              reduce using rule 51 (function -> FUNCTION funcbody .)
    FOR             reduce using rule 51 (function -> FUNCTION funcbody .)
    FUNCTION        reduce using rule 51 (function -> FUNCTION funcbody .)
    LOCAL           reduce using rule 51 (function -> FUNCTION funcbody .)
    NAME            reduce using rule 51 (function -> FUNCTION funcbody .)
    LPAREN          reduce using rule 51 (function -> FUNCTION funcbody .)
    RBRACK          reduce using rule 51 (function -> FUNCTION funcbody .)


state 86

    (52) funcbody -> LPAREN . opt_parlist RPAREN block END
    (90) opt_parlist -> . parlist
    (91) opt_parlist -> . empty
    (53) parlist -> . namelist opt_comma_ellipsis
    (54) parlist -> . ELLIPSIS
    (103) empty -> .
    (31) namelist -> . NAME namelist_tail

    ELLIPSIS        shift and go to state 125
    RPAREN          reduce using rule 103 (empty -> .)
    NAME            shift and go to state 56

    opt_parlist                    shift and go to state 121
    parlist                        shift and go to state 122
    empty                          shift and go to state 123
    namelist                       shift and go to state 124

state 87

    (55) tableconstructor -> LBRACE opt_fieldlist . RBRACE

    RBRACE          shift and go to state 126


state 88

    (88) opt_fieldlist -> fieldlist .

    RBRACE          reduce using rule 88 (opt_fieldlist -> fieldlist .)


state 89

    (89) opt_fieldlist -> empty .

    RBRACE          reduce using rule 89 (opt_fieldlist -> empty .)


state 90

    (56) fieldlist -> field . field_tail
    (57) field_tail -> . fieldsep field field_tail
    (58) field_tail -> . empty
    (62) fieldsep -> . COMMA
    (63) fieldsep -> . SEMI
    (103) empty -> .

    COMMA           shift and go to state 130
    SEMI            shift and go to state 131
    RBRACE          reduce using rule 103 (empty -> .)

    field_tail                     shift and go to state 127
    fieldsep                       shift and go to state 128
    empty                          shift and go to state 129

state 91

    (59) field -> LBRACK . exp RBRACK ASSIGN exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 132
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 92

    (61) field -> exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    COMMA           reduce using rule 61 (field -> exp .)
    SEMI            reduce using rule 61 (field -> exp .)
    RBRACE          reduce using rule 61 (field -> exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 93

    (60) field -> NAME . ASSIGN exp
    (23) var -> NAME .
    (26) functioncall -> NAME . LPAREN opt_explist RPAREN

    ASSIGN          shift and go to state 133
    LBRACK          reduce using rule 23 (var -> NAME .)
    DOT             reduce using rule 23 (var -> NAME .)
    COLON           reduce using rule 23 (var -> NAME .)
    PLUS            reduce using rule 23 (var -> NAME .)
    MINUS           reduce using rule 23 (var -> NAME .)
    TIMES           reduce using rule 23 (var -> NAME .)
    DIVIDE          reduce using rule 23 (var -> NAME .)
    POWER           reduce using rule 23 (var -> NAME .)
    MOD             reduce using rule 23 (var -> NAME .)
    CONCAT          reduce using rule 23 (var -> NAME .)
    LT              reduce using rule 23 (var -> NAME .)
    LE              reduce using rule 23 (var -> NAME .)
    GT              reduce using rule 23 (var -> NAME .)
    GE              reduce using rule 23 (var -> NAME .)
    EQ              reduce using rule 23 (var -> NAME .)
    NE              reduce using rule 23 (var -> NAME .)
    AND             reduce using rule 23 (var -> NAME .)
    OR              reduce using rule 23 (var -> NAME .)
    COMMA           reduce using rule 23 (var -> NAME .)
    SEMI            reduce using rule 23 (var -> NAME .)
    RBRACE          reduce using rule 23 (var -> NAME .)
    LPAREN          shift and go to state 52


state 94

    (6) stat -> varlist ASSIGN explist .

    SEMI            reduce using rule 6 (stat -> varlist ASSIGN explist .)
    RETURN          reduce using rule 6 (stat -> varlist ASSIGN explist .)
    BREAK           reduce using rule 6 (stat -> varlist ASSIGN explist .)
    DO              reduce using rule 6 (stat -> varlist ASSIGN explist .)
    WHILE           reduce using rule 6 (stat -> varlist ASSIGN explist .)
    REPEAT          reduce using rule 6 (stat -> varlist ASSIGN explist .)
    IF              reduce using rule 6 (stat -> varlist ASSIGN explist .)
    FOR             reduce using rule 6 (stat -> varlist ASSIGN explist .)
    FUNCTION        reduce using rule 6 (stat -> varlist ASSIGN explist .)
    LOCAL           reduce using rule 6 (stat -> varlist ASSIGN explist .)
    NAME            reduce using rule 6 (stat -> varlist ASSIGN explist .)
    LPAREN          reduce using rule 6 (stat -> varlist ASSIGN explist .)
    $end            reduce using rule 6 (stat -> varlist ASSIGN explist .)
    END             reduce using rule 6 (stat -> varlist ASSIGN explist .)
    UNTIL           reduce using rule 6 (stat -> varlist ASSIGN explist .)
    ELSEIF          reduce using rule 6 (stat -> varlist ASSIGN explist .)
    ELSE            reduce using rule 6 (stat -> varlist ASSIGN explist .)


state 95

    (8) stat -> DO block END .

    SEMI            reduce using rule 8 (stat -> DO block END .)
    RETURN          reduce using rule 8 (stat -> DO block END .)
    BREAK           reduce using rule 8 (stat -> DO block END .)
    DO              reduce using rule 8 (stat -> DO block END .)
    WHILE           reduce using rule 8 (stat -> DO block END .)
    REPEAT          reduce using rule 8 (stat -> DO block END .)
    IF              reduce using rule 8 (stat -> DO block END .)
    FOR             reduce using rule 8 (stat -> DO block END .)
    FUNCTION        reduce using rule 8 (stat -> DO block END .)
    LOCAL           reduce using rule 8 (stat -> DO block END .)
    NAME            reduce using rule 8 (stat -> DO block END .)
    LPAREN          reduce using rule 8 (stat -> DO block END .)
    $end            reduce using rule 8 (stat -> DO block END .)
    END             reduce using rule 8 (stat -> DO block END .)
    UNTIL           reduce using rule 8 (stat -> DO block END .)
    ELSEIF          reduce using rule 8 (stat -> DO block END .)
    ELSE            reduce using rule 8 (stat -> DO block END .)


state 96

    (9) stat -> WHILE exp DO . block END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 134
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 97

    (10) stat -> REPEAT block UNTIL . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 135
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 98

    (11) stat -> IF exp THEN . block elseiflist opt_else END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 136
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 99

    (12) stat -> FOR NAME ASSIGN . exp COMMA exp opt_comma_exp DO block END
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 137
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 100

    (32) namelist_tail -> COMMA . NAME namelist_tail

    NAME            shift and go to state 138


state 101

    (31) namelist -> NAME namelist_tail .

    IN              reduce using rule 31 (namelist -> NAME namelist_tail .)
    ASSIGN          reduce using rule 31 (namelist -> NAME namelist_tail .)
    SEMI            reduce using rule 31 (namelist -> NAME namelist_tail .)
    RETURN          reduce using rule 31 (namelist -> NAME namelist_tail .)
    BREAK           reduce using rule 31 (namelist -> NAME namelist_tail .)
    DO              reduce using rule 31 (namelist -> NAME namelist_tail .)
    WHILE           reduce using rule 31 (namelist -> NAME namelist_tail .)
    REPEAT          reduce using rule 31 (namelist -> NAME namelist_tail .)
    IF              reduce using rule 31 (namelist -> NAME namelist_tail .)
    FOR             reduce using rule 31 (namelist -> NAME namelist_tail .)
    FUNCTION        reduce using rule 31 (namelist -> NAME namelist_tail .)
    LOCAL           reduce using rule 31 (namelist -> NAME namelist_tail .)
    NAME            reduce using rule 31 (namelist -> NAME namelist_tail .)
    LPAREN          reduce using rule 31 (namelist -> NAME namelist_tail .)
    $end            reduce using rule 31 (namelist -> NAME namelist_tail .)
    END             reduce using rule 31 (namelist -> NAME namelist_tail .)
    UNTIL           reduce using rule 31 (namelist -> NAME namelist_tail .)
    ELSEIF          reduce using rule 31 (namelist -> NAME namelist_tail .)
    ELSE            reduce using rule 31 (namelist -> NAME namelist_tail .)
    COMMA           reduce using rule 31 (namelist -> NAME namelist_tail .)
    RPAREN          reduce using rule 31 (namelist -> NAME namelist_tail .)


state 102

    (33) namelist_tail -> empty .

    IN              reduce using rule 33 (namelist_tail -> empty .)
    ASSIGN          reduce using rule 33 (namelist_tail -> empty .)
    SEMI            reduce using rule 33 (namelist_tail -> empty .)
    RETURN          reduce using rule 33 (namelist_tail -> empty .)
    BREAK           reduce using rule 33 (namelist_tail -> empty .)
    DO              reduce using rule 33 (namelist_tail -> empty .)
    WHILE           reduce using rule 33 (namelist_tail -> empty .)
    REPEAT          reduce using rule 33 (namelist_tail -> empty .)
    IF              reduce using rule 33 (namelist_tail -> empty .)
    FOR             reduce using rule 33 (namelist_tail -> empty .)
    FUNCTION        reduce using rule 33 (namelist_tail -> empty .)
    LOCAL           reduce using rule 33 (namelist_tail -> empty .)
    NAME            reduce using rule 33 (namelist_tail -> empty .)
    LPAREN          reduce using rule 33 (namelist_tail -> empty .)
    $end            reduce using rule 33 (namelist_tail -> empty .)
    END             reduce using rule 33 (namelist_tail -> empty .)
    UNTIL           reduce using rule 33 (namelist_tail -> empty .)
    ELSEIF          reduce using rule 33 (namelist_tail -> empty .)
    ELSE            reduce using rule 33 (namelist_tail -> empty .)
    COMMA           reduce using rule 33 (namelist_tail -> empty .)
    RPAREN          reduce using rule 33 (namelist_tail -> empty .)


state 103

    (13) stat -> FOR namelist IN . explist DO block END
    (34) explist -> . exp exp_tail
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    explist                        shift and go to state 139
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 104

    (26) functioncall -> NAME LPAREN opt_explist . RPAREN

    RPAREN          shift and go to state 140


state 105

    (14) stat -> FUNCTION funcname funcbody .

    SEMI            reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    RETURN          reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    BREAK           reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    DO              reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    WHILE           reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    REPEAT          reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    IF              reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    FOR             reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    FUNCTION        reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    LOCAL           reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    NAME            reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    LPAREN          reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    $end            reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    END             reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    UNTIL           reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    ELSEIF          reduce using rule 14 (stat -> FUNCTION funcname funcbody .)
    ELSE            reduce using rule 14 (stat -> FUNCTION funcname funcbody .)


state 106

    (19) funcname -> NAME nameparts . opt_colon_name
    (100) opt_colon_name -> . COLON NAME
    (101) opt_colon_name -> . empty
    (103) empty -> .

    COLON           shift and go to state 142
    LPAREN          reduce using rule 103 (empty -> .)

    opt_colon_name                 shift and go to state 141
    empty                          shift and go to state 143

state 107

    (98) nameparts -> DOT . NAME nameparts

    NAME            shift and go to state 144


state 108

    (99) nameparts -> empty .

    COLON           reduce using rule 99 (nameparts -> empty .)
    LPAREN          reduce using rule 99 (nameparts -> empty .)


state 109

    (15) stat -> LOCAL FUNCTION NAME . funcbody
    (52) funcbody -> . LPAREN opt_parlist RPAREN block END

    LPAREN          shift and go to state 86

    funcbody                       shift and go to state 145

state 110

    (16) stat -> LOCAL namelist opt_assign .

    SEMI            reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    RETURN          reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    BREAK           reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    DO              reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    WHILE           reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    REPEAT          reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    IF              reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    FOR             reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    FUNCTION        reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    LOCAL           reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    NAME            reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    LPAREN          reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    $end            reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    END             reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    UNTIL           reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    ELSEIF          reduce using rule 16 (stat -> LOCAL namelist opt_assign .)
    ELSE            reduce using rule 16 (stat -> LOCAL namelist opt_assign .)


state 111

    (86) opt_assign -> ASSIGN . explist
    (34) explist -> . exp exp_tail
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    explist                        shift and go to state 146
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 112

    (87) opt_assign -> empty .

    SEMI            reduce using rule 87 (opt_assign -> empty .)
    RETURN          reduce using rule 87 (opt_assign -> empty .)
    BREAK           reduce using rule 87 (opt_assign -> empty .)
    DO              reduce using rule 87 (opt_assign -> empty .)
    WHILE           reduce using rule 87 (opt_assign -> empty .)
    REPEAT          reduce using rule 87 (opt_assign -> empty .)
    IF              reduce using rule 87 (opt_assign -> empty .)
    FOR             reduce using rule 87 (opt_assign -> empty .)
    FUNCTION        reduce using rule 87 (opt_assign -> empty .)
    LOCAL           reduce using rule 87 (opt_assign -> empty .)
    NAME            reduce using rule 87 (opt_assign -> empty .)
    LPAREN          reduce using rule 87 (opt_assign -> empty .)
    $end            reduce using rule 87 (opt_assign -> empty .)
    END             reduce using rule 87 (opt_assign -> empty .)
    UNTIL           reduce using rule 87 (opt_assign -> empty .)
    ELSEIF          reduce using rule 87 (opt_assign -> empty .)
    ELSE            reduce using rule 87 (opt_assign -> empty .)


state 113

    (21) varlist_tail -> COMMA var . varlist_tail
    (48) prefixexp -> var .
    (21) varlist_tail -> . COMMA var varlist_tail
    (22) varlist_tail -> . empty
    (103) empty -> .

    LBRACK          reduce using rule 48 (prefixexp -> var .)
    DOT             reduce using rule 48 (prefixexp -> var .)
    COLON           reduce using rule 48 (prefixexp -> var .)
    COMMA           shift and go to state 59
    ASSIGN          reduce using rule 103 (empty -> .)

    varlist_tail                   shift and go to state 147
    empty                          shift and go to state 60

state 114

    (24) var -> prefixexp . LBRACK exp RBRACK
    (25) var -> prefixexp . DOT NAME
    (27) functioncall -> prefixexp . COLON NAME args

    LBRACK          shift and go to state 63
    DOT             shift and go to state 64
    COLON           shift and go to state 62


state 115

    (50) prefixexp -> LPAREN exp RPAREN .

    COLON           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    LBRACK          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    DOT             reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    CONCAT          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    LE              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    GE              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    EQ              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    $end            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    END             reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    UNTIL           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    ELSEIF          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    DO              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    THEN            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    RBRACE          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    RETURN          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    BREAK           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    REPEAT          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    IF              reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    FOR             reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    FUNCTION        reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    LOCAL           reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    NAME            reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)
    RBRACK          reduce using rule 50 (prefixexp -> LPAREN exp RPAREN .)


state 116

    (27) functioncall -> prefixexp COLON NAME . args
    (28) args -> . LPAREN opt_explist RPAREN
    (29) args -> . tableconstructor
    (30) args -> . STRING
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE

    LPAREN          shift and go to state 149
    STRING          shift and go to state 151
    LBRACE          shift and go to state 39

    args                           shift and go to state 148
    tableconstructor               shift and go to state 150

state 117

    (24) var -> prefixexp LBRACK exp . RBRACK
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    RBRACK          shift and go to state 152
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 118

    (25) var -> prefixexp DOT NAME .

    COMMA           reduce using rule 25 (var -> prefixexp DOT NAME .)
    ASSIGN          reduce using rule 25 (var -> prefixexp DOT NAME .)
    COLON           reduce using rule 25 (var -> prefixexp DOT NAME .)
    LBRACK          reduce using rule 25 (var -> prefixexp DOT NAME .)
    DOT             reduce using rule 25 (var -> prefixexp DOT NAME .)
    PLUS            reduce using rule 25 (var -> prefixexp DOT NAME .)
    MINUS           reduce using rule 25 (var -> prefixexp DOT NAME .)
    TIMES           reduce using rule 25 (var -> prefixexp DOT NAME .)
    DIVIDE          reduce using rule 25 (var -> prefixexp DOT NAME .)
    POWER           reduce using rule 25 (var -> prefixexp DOT NAME .)
    MOD             reduce using rule 25 (var -> prefixexp DOT NAME .)
    CONCAT          reduce using rule 25 (var -> prefixexp DOT NAME .)
    LT              reduce using rule 25 (var -> prefixexp DOT NAME .)
    LE              reduce using rule 25 (var -> prefixexp DOT NAME .)
    GT              reduce using rule 25 (var -> prefixexp DOT NAME .)
    GE              reduce using rule 25 (var -> prefixexp DOT NAME .)
    EQ              reduce using rule 25 (var -> prefixexp DOT NAME .)
    NE              reduce using rule 25 (var -> prefixexp DOT NAME .)
    AND             reduce using rule 25 (var -> prefixexp DOT NAME .)
    OR              reduce using rule 25 (var -> prefixexp DOT NAME .)
    $end            reduce using rule 25 (var -> prefixexp DOT NAME .)
    END             reduce using rule 25 (var -> prefixexp DOT NAME .)
    UNTIL           reduce using rule 25 (var -> prefixexp DOT NAME .)
    ELSEIF          reduce using rule 25 (var -> prefixexp DOT NAME .)
    ELSE            reduce using rule 25 (var -> prefixexp DOT NAME .)
    DO              reduce using rule 25 (var -> prefixexp DOT NAME .)
    THEN            reduce using rule 25 (var -> prefixexp DOT NAME .)
    RPAREN          reduce using rule 25 (var -> prefixexp DOT NAME .)
    SEMI            reduce using rule 25 (var -> prefixexp DOT NAME .)
    RBRACE          reduce using rule 25 (var -> prefixexp DOT NAME .)
    RETURN          reduce using rule 25 (var -> prefixexp DOT NAME .)
    BREAK           reduce using rule 25 (var -> prefixexp DOT NAME .)
    WHILE           reduce using rule 25 (var -> prefixexp DOT NAME .)
    REPEAT          reduce using rule 25 (var -> prefixexp DOT NAME .)
    IF              reduce using rule 25 (var -> prefixexp DOT NAME .)
    FOR             reduce using rule 25 (var -> prefixexp DOT NAME .)
    FUNCTION        reduce using rule 25 (var -> prefixexp DOT NAME .)
    LOCAL           reduce using rule 25 (var -> prefixexp DOT NAME .)
    NAME            reduce using rule 25 (var -> prefixexp DOT NAME .)
    LPAREN          reduce using rule 25 (var -> prefixexp DOT NAME .)
    RBRACK          reduce using rule 25 (var -> prefixexp DOT NAME .)


state 119

    (46) exp -> exp binop exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 46 (exp -> exp binop exp .)
    $end            reduce using rule 46 (exp -> exp binop exp .)
    END             reduce using rule 46 (exp -> exp binop exp .)
    UNTIL           reduce using rule 46 (exp -> exp binop exp .)
    ELSEIF          reduce using rule 46 (exp -> exp binop exp .)
    ELSE            reduce using rule 46 (exp -> exp binop exp .)
    DO              reduce using rule 46 (exp -> exp binop exp .)
    THEN            reduce using rule 46 (exp -> exp binop exp .)
    RPAREN          reduce using rule 46 (exp -> exp binop exp .)
    SEMI            reduce using rule 46 (exp -> exp binop exp .)
    RBRACE          reduce using rule 46 (exp -> exp binop exp .)
    RETURN          reduce using rule 46 (exp -> exp binop exp .)
    BREAK           reduce using rule 46 (exp -> exp binop exp .)
    WHILE           reduce using rule 46 (exp -> exp binop exp .)
    REPEAT          reduce using rule 46 (exp -> exp binop exp .)
    IF              reduce using rule 46 (exp -> exp binop exp .)
    FOR             reduce using rule 46 (exp -> exp binop exp .)
    FUNCTION        reduce using rule 46 (exp -> exp binop exp .)
    LOCAL           reduce using rule 46 (exp -> exp binop exp .)
    NAME            reduce using rule 46 (exp -> exp binop exp .)
    LPAREN          reduce using rule 46 (exp -> exp binop exp .)
    RBRACK          reduce using rule 46 (exp -> exp binop exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

  ! PLUS            [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! TIMES           [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! POWER           [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! CONCAT          [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! LE              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! GE              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! EQ              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! NE              [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp binop exp .) ]
  ! OR              [ reduce using rule 46 (exp -> exp binop exp .) ]

    binop                          shift and go to state 66

state 120

    (35) exp_tail -> COMMA exp . exp_tail
    (46) exp -> exp . binop exp
    (35) exp_tail -> . COMMA exp exp_tail
    (36) exp_tail -> . empty
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR
    (103) empty -> .

    COMMA           shift and go to state 67
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    SEMI            reduce using rule 103 (empty -> .)
    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    RPAREN          reduce using rule 103 (empty -> .)

    exp_tail                       shift and go to state 153
    binop                          shift and go to state 66
    empty                          shift and go to state 68

state 121

    (52) funcbody -> LPAREN opt_parlist . RPAREN block END

    RPAREN          shift and go to state 154


state 122

    (90) opt_parlist -> parlist .

    RPAREN          reduce using rule 90 (opt_parlist -> parlist .)


state 123

    (91) opt_parlist -> empty .

    RPAREN          reduce using rule 91 (opt_parlist -> empty .)


state 124

    (53) parlist -> namelist . opt_comma_ellipsis
    (94) opt_comma_ellipsis -> . COMMA ELLIPSIS
    (95) opt_comma_ellipsis -> . empty
    (103) empty -> .

    COMMA           shift and go to state 156
    RPAREN          reduce using rule 103 (empty -> .)

    opt_comma_ellipsis             shift and go to state 155
    empty                          shift and go to state 157

state 125

    (54) parlist -> ELLIPSIS .

    RPAREN          reduce using rule 54 (parlist -> ELLIPSIS .)


state 126

    (55) tableconstructor -> LBRACE opt_fieldlist RBRACE .

    COMMA           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    PLUS            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    MINUS           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    TIMES           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    DIVIDE          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    POWER           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    MOD             reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    CONCAT          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    LT              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    LE              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    GT              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    GE              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    EQ              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    NE              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    AND             reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    OR              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    $end            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    END             reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    UNTIL           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    ELSEIF          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    ELSE            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    DO              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    THEN            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    RPAREN          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    SEMI            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    RBRACE          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    RETURN          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    BREAK           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    WHILE           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    REPEAT          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    IF              reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    FOR             reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    FUNCTION        reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    LOCAL           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    NAME            reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    LPAREN          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    RBRACK          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    COLON           reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    LBRACK          reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)
    DOT             reduce using rule 55 (tableconstructor -> LBRACE opt_fieldlist RBRACE .)


state 127

    (56) fieldlist -> field field_tail .

    RBRACE          reduce using rule 56 (fieldlist -> field field_tail .)


state 128

    (57) field_tail -> fieldsep . field field_tail
    (59) field -> . LBRACK exp RBRACK ASSIGN exp
    (60) field -> . NAME ASSIGN exp
    (61) field -> . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    LBRACK          shift and go to state 91
    NAME            shift and go to state 93
    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42

    field                          shift and go to state 158
    exp                            shift and go to state 92
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 129

    (58) field_tail -> empty .

    RBRACE          reduce using rule 58 (field_tail -> empty .)


state 130

    (62) fieldsep -> COMMA .

    LBRACK          reduce using rule 62 (fieldsep -> COMMA .)
    NAME            reduce using rule 62 (fieldsep -> COMMA .)
    NIL             reduce using rule 62 (fieldsep -> COMMA .)
    FALSE           reduce using rule 62 (fieldsep -> COMMA .)
    TRUE            reduce using rule 62 (fieldsep -> COMMA .)
    NUMBER          reduce using rule 62 (fieldsep -> COMMA .)
    STRING          reduce using rule 62 (fieldsep -> COMMA .)
    ELLIPSIS        reduce using rule 62 (fieldsep -> COMMA .)
    FUNCTION        reduce using rule 62 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 62 (fieldsep -> COMMA .)
    LBRACE          reduce using rule 62 (fieldsep -> COMMA .)
    MINUS           reduce using rule 62 (fieldsep -> COMMA .)
    NOT             reduce using rule 62 (fieldsep -> COMMA .)
    LEN             reduce using rule 62 (fieldsep -> COMMA .)


state 131

    (63) fieldsep -> SEMI .

    LBRACK          reduce using rule 63 (fieldsep -> SEMI .)
    NAME            reduce using rule 63 (fieldsep -> SEMI .)
    NIL             reduce using rule 63 (fieldsep -> SEMI .)
    FALSE           reduce using rule 63 (fieldsep -> SEMI .)
    TRUE            reduce using rule 63 (fieldsep -> SEMI .)
    NUMBER          reduce using rule 63 (fieldsep -> SEMI .)
    STRING          reduce using rule 63 (fieldsep -> SEMI .)
    ELLIPSIS        reduce using rule 63 (fieldsep -> SEMI .)
    FUNCTION        reduce using rule 63 (fieldsep -> SEMI .)
    LPAREN          reduce using rule 63 (fieldsep -> SEMI .)
    LBRACE          reduce using rule 63 (fieldsep -> SEMI .)
    MINUS           reduce using rule 63 (fieldsep -> SEMI .)
    NOT             reduce using rule 63 (fieldsep -> SEMI .)
    LEN             reduce using rule 63 (fieldsep -> SEMI .)


state 132

    (59) field -> LBRACK exp . RBRACK ASSIGN exp
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    RBRACK          shift and go to state 159
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 133

    (60) field -> NAME ASSIGN . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 160
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 134

    (9) stat -> WHILE exp DO block . END

    END             shift and go to state 161


state 135

    (10) stat -> REPEAT block UNTIL exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    SEMI            reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    RETURN          reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    BREAK           reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    DO              reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    WHILE           reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    REPEAT          reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    IF              reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    FOR             reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    FUNCTION        reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    LOCAL           reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    NAME            reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    LPAREN          reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    $end            reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    END             reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    UNTIL           reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    ELSEIF          reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    ELSE            reduce using rule 10 (stat -> REPEAT block UNTIL exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 136

    (11) stat -> IF exp THEN block . elseiflist opt_else END
    (96) elseiflist -> . elseiflist ELSEIF exp THEN block
    (97) elseiflist -> . empty
    (103) empty -> .

    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    elseiflist                     shift and go to state 162
    empty                          shift and go to state 163

state 137

    (12) stat -> FOR NAME ASSIGN exp . COMMA exp opt_comma_exp DO block END
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    COMMA           shift and go to state 164
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 138

    (32) namelist_tail -> COMMA NAME . namelist_tail
    (32) namelist_tail -> . COMMA NAME namelist_tail
    (33) namelist_tail -> . empty
    (103) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 100
    IN              reduce using rule 103 (empty -> .)
    ASSIGN          reduce using rule 103 (empty -> .)
    SEMI            reduce using rule 103 (empty -> .)
    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    $end            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)
    UNTIL           reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    RPAREN          reduce using rule 103 (empty -> .)

  ! COMMA           [ reduce using rule 103 (empty -> .) ]

    namelist_tail                  shift and go to state 165
    empty                          shift and go to state 102

state 139

    (13) stat -> FOR namelist IN explist . DO block END

    DO              shift and go to state 166


state 140

    (26) functioncall -> NAME LPAREN opt_explist RPAREN .

    SEMI            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    RETURN          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    BREAK           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    DO              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    WHILE           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    REPEAT          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    IF              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    FOR             reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    FUNCTION        reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    LOCAL           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    NAME            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    LPAREN          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    $end            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    END             reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    UNTIL           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    ELSEIF          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    ELSE            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    COLON           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    LBRACK          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    DOT             reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    COMMA           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    PLUS            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    MINUS           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    TIMES           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    DIVIDE          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    POWER           reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    MOD             reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    CONCAT          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    LT              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    LE              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    GT              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    GE              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    EQ              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    NE              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    AND             reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    OR              reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    THEN            reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    RPAREN          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    RBRACE          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)
    RBRACK          reduce using rule 26 (functioncall -> NAME LPAREN opt_explist RPAREN .)


state 141

    (19) funcname -> NAME nameparts opt_colon_name .

    LPAREN          reduce using rule 19 (funcname -> NAME nameparts opt_colon_name .)


state 142

    (100) opt_colon_name -> COLON . NAME

    NAME            shift and go to state 167


state 143

    (101) opt_colon_name -> empty .

    LPAREN          reduce using rule 101 (opt_colon_name -> empty .)


state 144

    (98) nameparts -> DOT NAME . nameparts
    (98) nameparts -> . DOT NAME nameparts
    (99) nameparts -> . empty
    (103) empty -> .

    DOT             shift and go to state 107
    COLON           reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)

    nameparts                      shift and go to state 168
    empty                          shift and go to state 108

state 145

    (15) stat -> LOCAL FUNCTION NAME funcbody .

    SEMI            reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    RETURN          reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    BREAK           reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    DO              reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    WHILE           reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    REPEAT          reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    IF              reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    FOR             reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    FUNCTION        reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    LOCAL           reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    NAME            reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    LPAREN          reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    $end            reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    END             reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    UNTIL           reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    ELSEIF          reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)
    ELSE            reduce using rule 15 (stat -> LOCAL FUNCTION NAME funcbody .)


state 146

    (86) opt_assign -> ASSIGN explist .

    SEMI            reduce using rule 86 (opt_assign -> ASSIGN explist .)
    RETURN          reduce using rule 86 (opt_assign -> ASSIGN explist .)
    BREAK           reduce using rule 86 (opt_assign -> ASSIGN explist .)
    DO              reduce using rule 86 (opt_assign -> ASSIGN explist .)
    WHILE           reduce using rule 86 (opt_assign -> ASSIGN explist .)
    REPEAT          reduce using rule 86 (opt_assign -> ASSIGN explist .)
    IF              reduce using rule 86 (opt_assign -> ASSIGN explist .)
    FOR             reduce using rule 86 (opt_assign -> ASSIGN explist .)
    FUNCTION        reduce using rule 86 (opt_assign -> ASSIGN explist .)
    LOCAL           reduce using rule 86 (opt_assign -> ASSIGN explist .)
    NAME            reduce using rule 86 (opt_assign -> ASSIGN explist .)
    LPAREN          reduce using rule 86 (opt_assign -> ASSIGN explist .)
    $end            reduce using rule 86 (opt_assign -> ASSIGN explist .)
    END             reduce using rule 86 (opt_assign -> ASSIGN explist .)
    UNTIL           reduce using rule 86 (opt_assign -> ASSIGN explist .)
    ELSEIF          reduce using rule 86 (opt_assign -> ASSIGN explist .)
    ELSE            reduce using rule 86 (opt_assign -> ASSIGN explist .)


state 147

    (21) varlist_tail -> COMMA var varlist_tail .

    ASSIGN          reduce using rule 21 (varlist_tail -> COMMA var varlist_tail .)


state 148

    (27) functioncall -> prefixexp COLON NAME args .

    SEMI            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    RETURN          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    BREAK           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    DO              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    WHILE           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    REPEAT          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    IF              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    FOR             reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    FUNCTION        reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    LOCAL           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    NAME            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    LPAREN          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    $end            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    END             reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    UNTIL           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    ELSEIF          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    ELSE            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    COLON           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    LBRACK          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    DOT             reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    COMMA           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    PLUS            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    MINUS           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    TIMES           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    DIVIDE          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    POWER           reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    MOD             reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    CONCAT          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    LT              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    LE              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    GT              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    GE              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    EQ              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    NE              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    AND             reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    OR              reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    THEN            reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    RPAREN          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    RBRACE          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)
    RBRACK          reduce using rule 27 (functioncall -> prefixexp COLON NAME args .)


state 149

    (28) args -> LPAREN . opt_explist RPAREN
    (82) opt_explist -> . explist
    (83) opt_explist -> . empty
    (34) explist -> . exp exp_tail
    (103) empty -> .
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    RPAREN          reduce using rule 103 (empty -> .)
    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    opt_explist                    shift and go to state 169
    explist                        shift and go to state 23
    empty                          shift and go to state 24
    exp                            shift and go to state 25
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 150

    (29) args -> tableconstructor .

    SEMI            reduce using rule 29 (args -> tableconstructor .)
    RETURN          reduce using rule 29 (args -> tableconstructor .)
    BREAK           reduce using rule 29 (args -> tableconstructor .)
    DO              reduce using rule 29 (args -> tableconstructor .)
    WHILE           reduce using rule 29 (args -> tableconstructor .)
    REPEAT          reduce using rule 29 (args -> tableconstructor .)
    IF              reduce using rule 29 (args -> tableconstructor .)
    FOR             reduce using rule 29 (args -> tableconstructor .)
    FUNCTION        reduce using rule 29 (args -> tableconstructor .)
    LOCAL           reduce using rule 29 (args -> tableconstructor .)
    NAME            reduce using rule 29 (args -> tableconstructor .)
    LPAREN          reduce using rule 29 (args -> tableconstructor .)
    $end            reduce using rule 29 (args -> tableconstructor .)
    END             reduce using rule 29 (args -> tableconstructor .)
    UNTIL           reduce using rule 29 (args -> tableconstructor .)
    ELSEIF          reduce using rule 29 (args -> tableconstructor .)
    ELSE            reduce using rule 29 (args -> tableconstructor .)
    COLON           reduce using rule 29 (args -> tableconstructor .)
    LBRACK          reduce using rule 29 (args -> tableconstructor .)
    DOT             reduce using rule 29 (args -> tableconstructor .)
    COMMA           reduce using rule 29 (args -> tableconstructor .)
    PLUS            reduce using rule 29 (args -> tableconstructor .)
    MINUS           reduce using rule 29 (args -> tableconstructor .)
    TIMES           reduce using rule 29 (args -> tableconstructor .)
    DIVIDE          reduce using rule 29 (args -> tableconstructor .)
    POWER           reduce using rule 29 (args -> tableconstructor .)
    MOD             reduce using rule 29 (args -> tableconstructor .)
    CONCAT          reduce using rule 29 (args -> tableconstructor .)
    LT              reduce using rule 29 (args -> tableconstructor .)
    LE              reduce using rule 29 (args -> tableconstructor .)
    GT              reduce using rule 29 (args -> tableconstructor .)
    GE              reduce using rule 29 (args -> tableconstructor .)
    EQ              reduce using rule 29 (args -> tableconstructor .)
    NE              reduce using rule 29 (args -> tableconstructor .)
    AND             reduce using rule 29 (args -> tableconstructor .)
    OR              reduce using rule 29 (args -> tableconstructor .)
    THEN            reduce using rule 29 (args -> tableconstructor .)
    RPAREN          reduce using rule 29 (args -> tableconstructor .)
    RBRACE          reduce using rule 29 (args -> tableconstructor .)
    RBRACK          reduce using rule 29 (args -> tableconstructor .)


state 151

    (30) args -> STRING .

    SEMI            reduce using rule 30 (args -> STRING .)
    RETURN          reduce using rule 30 (args -> STRING .)
    BREAK           reduce using rule 30 (args -> STRING .)
    DO              reduce using rule 30 (args -> STRING .)
    WHILE           reduce using rule 30 (args -> STRING .)
    REPEAT          reduce using rule 30 (args -> STRING .)
    IF              reduce using rule 30 (args -> STRING .)
    FOR             reduce using rule 30 (args -> STRING .)
    FUNCTION        reduce using rule 30 (args -> STRING .)
    LOCAL           reduce using rule 30 (args -> STRING .)
    NAME            reduce using rule 30 (args -> STRING .)
    LPAREN          reduce using rule 30 (args -> STRING .)
    $end            reduce using rule 30 (args -> STRING .)
    END             reduce using rule 30 (args -> STRING .)
    UNTIL           reduce using rule 30 (args -> STRING .)
    ELSEIF          reduce using rule 30 (args -> STRING .)
    ELSE            reduce using rule 30 (args -> STRING .)
    COLON           reduce using rule 30 (args -> STRING .)
    LBRACK          reduce using rule 30 (args -> STRING .)
    DOT             reduce using rule 30 (args -> STRING .)
    COMMA           reduce using rule 30 (args -> STRING .)
    PLUS            reduce using rule 30 (args -> STRING .)
    MINUS           reduce using rule 30 (args -> STRING .)
    TIMES           reduce using rule 30 (args -> STRING .)
    DIVIDE          reduce using rule 30 (args -> STRING .)
    POWER           reduce using rule 30 (args -> STRING .)
    MOD             reduce using rule 30 (args -> STRING .)
    CONCAT          reduce using rule 30 (args -> STRING .)
    LT              reduce using rule 30 (args -> STRING .)
    LE              reduce using rule 30 (args -> STRING .)
    GT              reduce using rule 30 (args -> STRING .)
    GE              reduce using rule 30 (args -> STRING .)
    EQ              reduce using rule 30 (args -> STRING .)
    NE              reduce using rule 30 (args -> STRING .)
    AND             reduce using rule 30 (args -> STRING .)
    OR              reduce using rule 30 (args -> STRING .)
    THEN            reduce using rule 30 (args -> STRING .)
    RPAREN          reduce using rule 30 (args -> STRING .)
    RBRACE          reduce using rule 30 (args -> STRING .)
    RBRACK          reduce using rule 30 (args -> STRING .)


state 152

    (24) var -> prefixexp LBRACK exp RBRACK .

    COMMA           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    ASSIGN          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    COLON           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    LBRACK          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    DOT             reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    PLUS            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    MINUS           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    TIMES           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    POWER           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    MOD             reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    CONCAT          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    LT              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    LE              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    GT              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    GE              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    EQ              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    NE              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    AND             reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    OR              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    $end            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    END             reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    UNTIL           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    ELSEIF          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    ELSE            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    DO              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    THEN            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    RPAREN          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    SEMI            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    RBRACE          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    RETURN          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    BREAK           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    WHILE           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    REPEAT          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    IF              reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    FOR             reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    FUNCTION        reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    LOCAL           reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    NAME            reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    LPAREN          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)
    RBRACK          reduce using rule 24 (var -> prefixexp LBRACK exp RBRACK .)


state 153

    (35) exp_tail -> COMMA exp exp_tail .

    $end            reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    END             reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    UNTIL           reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    ELSEIF          reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    ELSE            reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    SEMI            reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    RETURN          reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    BREAK           reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    DO              reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    WHILE           reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    REPEAT          reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    IF              reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    FOR             reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    FUNCTION        reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    LOCAL           reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    NAME            reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    LPAREN          reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)
    RPAREN          reduce using rule 35 (exp_tail -> COMMA exp exp_tail .)


state 154

    (52) funcbody -> LPAREN opt_parlist RPAREN . block END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 170
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 155

    (53) parlist -> namelist opt_comma_ellipsis .

    RPAREN          reduce using rule 53 (parlist -> namelist opt_comma_ellipsis .)


state 156

    (94) opt_comma_ellipsis -> COMMA . ELLIPSIS

    ELLIPSIS        shift and go to state 171


state 157

    (95) opt_comma_ellipsis -> empty .

    RPAREN          reduce using rule 95 (opt_comma_ellipsis -> empty .)


state 158

    (57) field_tail -> fieldsep field . field_tail
    (57) field_tail -> . fieldsep field field_tail
    (58) field_tail -> . empty
    (62) fieldsep -> . COMMA
    (63) fieldsep -> . SEMI
    (103) empty -> .

    COMMA           shift and go to state 130
    SEMI            shift and go to state 131
    RBRACE          reduce using rule 103 (empty -> .)

    fieldsep                       shift and go to state 128
    field_tail                     shift and go to state 172
    empty                          shift and go to state 129

state 159

    (59) field -> LBRACK exp RBRACK . ASSIGN exp

    ASSIGN          shift and go to state 173


state 160

    (60) field -> NAME ASSIGN exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    COMMA           reduce using rule 60 (field -> NAME ASSIGN exp .)
    SEMI            reduce using rule 60 (field -> NAME ASSIGN exp .)
    RBRACE          reduce using rule 60 (field -> NAME ASSIGN exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 161

    (9) stat -> WHILE exp DO block END .

    SEMI            reduce using rule 9 (stat -> WHILE exp DO block END .)
    RETURN          reduce using rule 9 (stat -> WHILE exp DO block END .)
    BREAK           reduce using rule 9 (stat -> WHILE exp DO block END .)
    DO              reduce using rule 9 (stat -> WHILE exp DO block END .)
    WHILE           reduce using rule 9 (stat -> WHILE exp DO block END .)
    REPEAT          reduce using rule 9 (stat -> WHILE exp DO block END .)
    IF              reduce using rule 9 (stat -> WHILE exp DO block END .)
    FOR             reduce using rule 9 (stat -> WHILE exp DO block END .)
    FUNCTION        reduce using rule 9 (stat -> WHILE exp DO block END .)
    LOCAL           reduce using rule 9 (stat -> WHILE exp DO block END .)
    NAME            reduce using rule 9 (stat -> WHILE exp DO block END .)
    LPAREN          reduce using rule 9 (stat -> WHILE exp DO block END .)
    $end            reduce using rule 9 (stat -> WHILE exp DO block END .)
    END             reduce using rule 9 (stat -> WHILE exp DO block END .)
    UNTIL           reduce using rule 9 (stat -> WHILE exp DO block END .)
    ELSEIF          reduce using rule 9 (stat -> WHILE exp DO block END .)
    ELSE            reduce using rule 9 (stat -> WHILE exp DO block END .)


state 162

    (11) stat -> IF exp THEN block elseiflist . opt_else END
    (96) elseiflist -> elseiflist . ELSEIF exp THEN block
    (92) opt_else -> . ELSE block
    (93) opt_else -> . empty
    (103) empty -> .

    ELSEIF          shift and go to state 175
    ELSE            shift and go to state 176
    END             reduce using rule 103 (empty -> .)

    opt_else                       shift and go to state 174
    empty                          shift and go to state 177

state 163

    (97) elseiflist -> empty .

    ELSEIF          reduce using rule 97 (elseiflist -> empty .)
    ELSE            reduce using rule 97 (elseiflist -> empty .)
    END             reduce using rule 97 (elseiflist -> empty .)


state 164

    (12) stat -> FOR NAME ASSIGN exp COMMA . exp opt_comma_exp DO block END
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 178
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 165

    (32) namelist_tail -> COMMA NAME namelist_tail .

    IN              reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    ASSIGN          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    SEMI            reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    RETURN          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    BREAK           reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    DO              reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    WHILE           reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    REPEAT          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    IF              reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    FOR             reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    FUNCTION        reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    LOCAL           reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    NAME            reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    LPAREN          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    $end            reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    END             reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    UNTIL           reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    ELSEIF          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    ELSE            reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    COMMA           reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)
    RPAREN          reduce using rule 32 (namelist_tail -> COMMA NAME namelist_tail .)


state 166

    (13) stat -> FOR namelist IN explist DO . block END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 179
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 167

    (100) opt_colon_name -> COLON NAME .

    LPAREN          reduce using rule 100 (opt_colon_name -> COLON NAME .)


state 168

    (98) nameparts -> DOT NAME nameparts .

    COLON           reduce using rule 98 (nameparts -> DOT NAME nameparts .)
    LPAREN          reduce using rule 98 (nameparts -> DOT NAME nameparts .)


state 169

    (28) args -> LPAREN opt_explist . RPAREN

    RPAREN          shift and go to state 180


state 170

    (52) funcbody -> LPAREN opt_parlist RPAREN block . END

    END             shift and go to state 181


state 171

    (94) opt_comma_ellipsis -> COMMA ELLIPSIS .

    RPAREN          reduce using rule 94 (opt_comma_ellipsis -> COMMA ELLIPSIS .)


state 172

    (57) field_tail -> fieldsep field field_tail .

    RBRACE          reduce using rule 57 (field_tail -> fieldsep field field_tail .)


state 173

    (59) field -> LBRACK exp RBRACK ASSIGN . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 182
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 174

    (11) stat -> IF exp THEN block elseiflist opt_else . END

    END             shift and go to state 183


state 175

    (96) elseiflist -> elseiflist ELSEIF . exp THEN block
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 184
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 176

    (92) opt_else -> ELSE . block
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 185
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 177

    (93) opt_else -> empty .

    END             reduce using rule 93 (opt_else -> empty .)


state 178

    (12) stat -> FOR NAME ASSIGN exp COMMA exp . opt_comma_exp DO block END
    (46) exp -> exp . binop exp
    (84) opt_comma_exp -> . COMMA exp
    (85) opt_comma_exp -> . empty
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR
    (103) empty -> .

    COMMA           shift and go to state 186
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    DO              reduce using rule 103 (empty -> .)

    opt_comma_exp                  shift and go to state 187
    binop                          shift and go to state 66
    empty                          shift and go to state 188

state 179

    (13) stat -> FOR namelist IN explist DO block . END

    END             shift and go to state 189


state 180

    (28) args -> LPAREN opt_explist RPAREN .

    SEMI            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    RETURN          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    BREAK           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    DO              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    WHILE           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    REPEAT          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    IF              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    FOR             reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    FUNCTION        reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    LOCAL           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    NAME            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    LPAREN          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    $end            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    END             reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    UNTIL           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    ELSEIF          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    ELSE            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    COLON           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    LBRACK          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    DOT             reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    COMMA           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    PLUS            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    MINUS           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    TIMES           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    DIVIDE          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    POWER           reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    MOD             reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    CONCAT          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    LT              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    LE              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    GT              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    GE              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    EQ              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    NE              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    AND             reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    OR              reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    THEN            reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    RPAREN          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    RBRACE          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)
    RBRACK          reduce using rule 28 (args -> LPAREN opt_explist RPAREN .)


state 181

    (52) funcbody -> LPAREN opt_parlist RPAREN block END .

    COMMA           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    PLUS            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    MINUS           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    TIMES           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    DIVIDE          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    POWER           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    MOD             reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    CONCAT          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    LT              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    LE              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    GT              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    GE              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    EQ              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    NE              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    AND             reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    OR              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    $end            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    END             reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    UNTIL           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    ELSEIF          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    ELSE            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    DO              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    THEN            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    RPAREN          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    SEMI            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    RBRACE          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    RETURN          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    BREAK           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    WHILE           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    REPEAT          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    IF              reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    FOR             reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    FUNCTION        reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    LOCAL           reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    NAME            reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    LPAREN          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)
    RBRACK          reduce using rule 52 (funcbody -> LPAREN opt_parlist RPAREN block END .)


state 182

    (59) field -> LBRACK exp RBRACK ASSIGN exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    COMMA           reduce using rule 59 (field -> LBRACK exp RBRACK ASSIGN exp .)
    SEMI            reduce using rule 59 (field -> LBRACK exp RBRACK ASSIGN exp .)
    RBRACE          reduce using rule 59 (field -> LBRACK exp RBRACK ASSIGN exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 183

    (11) stat -> IF exp THEN block elseiflist opt_else END .

    SEMI            reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    RETURN          reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    BREAK           reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    DO              reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    WHILE           reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    REPEAT          reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    IF              reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    FOR             reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    FUNCTION        reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    LOCAL           reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    NAME            reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    LPAREN          reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    $end            reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    END             reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    UNTIL           reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    ELSEIF          reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)
    ELSE            reduce using rule 11 (stat -> IF exp THEN block elseiflist opt_else END .)


state 184

    (96) elseiflist -> elseiflist ELSEIF exp . THEN block
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    THEN            shift and go to state 190
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 185

    (92) opt_else -> ELSE block .

    END             reduce using rule 92 (opt_else -> ELSE block .)


state 186

    (84) opt_comma_exp -> COMMA . exp
    (37) exp -> . NIL
    (38) exp -> . FALSE
    (39) exp -> . TRUE
    (40) exp -> . NUMBER
    (41) exp -> . STRING
    (42) exp -> . ELLIPSIS
    (43) exp -> . function
    (44) exp -> . prefixexp
    (45) exp -> . tableconstructor
    (46) exp -> . exp binop exp
    (47) exp -> . unop exp
    (51) function -> . FUNCTION funcbody
    (48) prefixexp -> . var
    (49) prefixexp -> . functioncall
    (50) prefixexp -> . LPAREN exp RPAREN
    (55) tableconstructor -> . LBRACE opt_fieldlist RBRACE
    (79) unop -> . MINUS
    (80) unop -> . NOT
    (81) unop -> . LEN
    (23) var -> . NAME
    (24) var -> . prefixexp LBRACK exp RBRACK
    (25) var -> . prefixexp DOT NAME
    (26) functioncall -> . NAME LPAREN opt_explist RPAREN
    (27) functioncall -> . prefixexp COLON NAME args

    NIL             shift and go to state 26
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    ELLIPSIS        shift and go to state 31
    FUNCTION        shift and go to state 36
    LPAREN          shift and go to state 19
    LBRACE          shift and go to state 39
    MINUS           shift and go to state 40
    NOT             shift and go to state 41
    LEN             shift and go to state 42
    NAME            shift and go to state 43

    exp                            shift and go to state 191
    function                       shift and go to state 32
    prefixexp                      shift and go to state 33
    tableconstructor               shift and go to state 34
    unop                           shift and go to state 35
    var                            shift and go to state 37
    functioncall                   shift and go to state 38

state 187

    (12) stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp . DO block END

    DO              shift and go to state 192


state 188

    (85) opt_comma_exp -> empty .

    DO              reduce using rule 85 (opt_comma_exp -> empty .)


state 189

    (13) stat -> FOR namelist IN explist DO block END .

    SEMI            reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    RETURN          reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    DO              reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    WHILE           reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    FUNCTION        reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    LOCAL           reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    NAME            reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    LPAREN          reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    $end            reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    END             reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    UNTIL           reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    ELSEIF          reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)
    ELSE            reduce using rule 13 (stat -> FOR namelist IN explist DO block END .)


state 190

    (96) elseiflist -> elseiflist ELSEIF exp THEN . block
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    ELSEIF          reduce using rule 103 (empty -> .)
    ELSE            reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 193
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 191

    (84) opt_comma_exp -> COMMA exp .
    (46) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . MOD
    (70) binop -> . CONCAT
    (71) binop -> . LT
    (72) binop -> . LE
    (73) binop -> . GT
    (74) binop -> . GE
    (75) binop -> . EQ
    (76) binop -> . NE
    (77) binop -> . AND
    (78) binop -> . OR

    DO              reduce using rule 84 (opt_comma_exp -> COMMA exp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74
    CONCAT          shift and go to state 75
    LT              shift and go to state 76
    LE              shift and go to state 77
    GT              shift and go to state 78
    GE              shift and go to state 79
    EQ              shift and go to state 80
    NE              shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83

    binop                          shift and go to state 66

state 192

    (12) stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO . block END
    (102) block -> . chunk
    (1) chunk -> . statlist
    (2) chunk -> . statlist laststat
    (3) statlist -> . statlist stat SEMI
    (4) statlist -> . statlist stat
    (5) statlist -> . empty
    (103) empty -> .

    RETURN          reduce using rule 103 (empty -> .)
    BREAK           reduce using rule 103 (empty -> .)
    DO              reduce using rule 103 (empty -> .)
    WHILE           reduce using rule 103 (empty -> .)
    REPEAT          reduce using rule 103 (empty -> .)
    IF              reduce using rule 103 (empty -> .)
    FOR             reduce using rule 103 (empty -> .)
    FUNCTION        reduce using rule 103 (empty -> .)
    LOCAL           reduce using rule 103 (empty -> .)
    NAME            reduce using rule 103 (empty -> .)
    LPAREN          reduce using rule 103 (empty -> .)
    END             reduce using rule 103 (empty -> .)

    block                          shift and go to state 194
    chunk                          shift and go to state 46
    statlist                       shift and go to state 2
    empty                          shift and go to state 3

state 193

    (96) elseiflist -> elseiflist ELSEIF exp THEN block .

    ELSEIF          reduce using rule 96 (elseiflist -> elseiflist ELSEIF exp THEN block .)
    ELSE            reduce using rule 96 (elseiflist -> elseiflist ELSEIF exp THEN block .)
    END             reduce using rule 96 (elseiflist -> elseiflist ELSEIF exp THEN block .)


state 194

    (12) stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block . END

    END             shift and go to state 195


state 195

    (12) stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .

    SEMI            reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    RETURN          reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    BREAK           reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    DO              reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    WHILE           reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    REPEAT          reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    IF              reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    FOR             reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    FUNCTION        reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    LOCAL           reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    NAME            reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    LPAREN          reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    $end            reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    END             reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    UNTIL           reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    ELSEIF          reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)
    ELSE            reduce using rule 12 (stat -> FOR NAME ASSIGN exp COMMA exp opt_comma_exp DO block END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for POWER in state 84 resolved as shift
WARNING: shift/reduce conflict for MOD in state 84 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 84 resolved as shift
WARNING: shift/reduce conflict for LT in state 84 resolved as shift
WARNING: shift/reduce conflict for LE in state 84 resolved as shift
WARNING: shift/reduce conflict for GT in state 84 resolved as shift
WARNING: shift/reduce conflict for GE in state 84 resolved as shift
WARNING: shift/reduce conflict for EQ in state 84 resolved as shift
WARNING: shift/reduce conflict for NE in state 84 resolved as shift
WARNING: shift/reduce conflict for AND in state 84 resolved as shift
WARNING: shift/reduce conflict for OR in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for POWER in state 119 resolved as shift
WARNING: shift/reduce conflict for MOD in state 119 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for LE in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for GE in state 119 resolved as shift
WARNING: shift/reduce conflict for EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for NE in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 138 resolved as shift
